<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Plane 1000x1000 - Delivery Missions</title>
  <style>
    html,body{height:100%;margin:0}
    #app{width:100%;height:100%;display:block;overflow:hidden}
    .info{position:fixed;left:10px;top:10px;background:rgba(0,0,0,0.6);color:#fff;padding:8px;border-radius:6px;font-family:sans-serif;white-space:pre-line}
    .mission{top:60px;left:10px}
    .house-info{top:180px;left:10px}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="info">WASD ƒë·ªÉ di chuy·ªÉn ‚Äî Space nh·∫£y (nh·ªè) ‚Äî Shift ch·∫°y ‚Äî E l√™n/xu·ªëng xe ‚Äî G l·∫•y/giao h√†ng ‚Äî R n·∫°p nhi√™n li·ªáu</div>

  <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

  <script type="module">
    
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';


    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0a0a0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('app').appendChild(renderer.domElement);

    const planeGeo = new THREE.PlaneGeometry(1000, 1000, 50, 50);
    const planeMat = new THREE.MeshStandardMaterial({color:0x808080, side:THREE.DoubleSide, roughness:0.9});
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI/2;
    plane.receiveShadow = true;
    scene.add(plane);

    const grid = new THREE.GridHelper(1000, 20, 0x444444, 0x888888);
    scene.add(grid);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0,200,0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(100,300,200);
    dir.castShadow = true;
    dir.shadow.camera.left = -500; dir.shadow.camera.right = 500;
    dir.shadow.camera.top = 500; dir.shadow.camera.bottom = -500;
    dir.shadow.mapSize.set(2048,2048);
    scene.add(dir);

    const playerSize = 10;
    const playerGeo = new THREE.BoxGeometry(playerSize, playerSize*2, playerSize);
    const playerMat = new THREE.MeshStandardMaterial({color:0x0099ff});
    const player = new THREE.Mesh(playerGeo, playerMat);
    player.castShadow = true;
    player.position.set(0, playerSize, 0);
    scene.add(player);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);

    const tiltRad = Math.PI/4;
    const followDistance = 200;

    const keys = {w:false,a:false,s:false,d:false,shift:false,space:false};
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if(k in keys) keys[k]=true;
    });
    window.addEventListener('keyup', e => {
      const k = e.key.toLowerCase();
      if(k in keys) keys[k]=false;
    });

    const walkSpeed = 0.4;
    const runMultiplier = 2.0;
    let verticalVel = 0;
    const gravity = -1.2;
    const jumpSpeed = 18;
    let onGround = true;

    const half = 500 - 10;

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const clock = new THREE.Clock();

    // ------- Mission & houses data -------
    const housePositions = []; // l∆∞u t·ªça ƒë·ªô c√°c nh√†
    let currentPickup = 1;   // Nh√† l·∫•y h√†ng
    let currentDrop = 2;     // Nh√† giao h√†ng
    let hasCargo = false;    // ƒêang c·∫ßm h√†ng hay kh√¥ng
    let coins = 0;           // Xu hi·ªán t·∫°i

    // UI nhi·ªám v·ª•
    const missionDiv = document.createElement('div');
    missionDiv.className = "info mission";
    missionDiv.style.top = "60px";
    missionDiv.innerText = '';
    document.body.appendChild(missionDiv);
    
    // UI th√¥ng tin nh√†
    const houseInfoDiv = document.createElement('div');
    houseInfoDiv.className = "info house-info";
    houseInfoDiv.style.top = "180px";
    houseInfoDiv.innerText = '';
    document.body.appendChild(houseInfoDiv);

    function updateMissionText(){
      const txt = hasCargo 
        ? `ƒêang gi·ªØ h√†ng, giao ƒë·∫øn nh√† ${currentDrop}` 
        : `H√£y l·∫•y h√†ng ·ªü nh√† ${currentPickup}`;
      missionDiv.innerText = `Nhi·ªám v·ª•: ${txt}\nXu: ${coins}`;
    }

    function newMission(start){
      currentPickup = start;
      currentDrop = (start % 20) + 1; // sau nh√† 20 l√† nh√† 1
      hasCargo = false;
      updateMissionText();
    }

    // ti·ªán √≠ch kho·∫£ng c√°ch theo XZ (2D)
    function distanceXZ(a, b){
      return Math.hypot(a.x - b.x, a.z - b.z);
    }

    // ------- Environment creators -------
    // ====== H√†m t·∫°o nhi·ªÅu lo·∫°i c√¢y ======
    function createTree(type, x, z) {
      let tree;
      if (type === 1) {
        // Tree1 - th√¢n tr·ª•, t√°n c·∫ßu
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(4, 6, 60, 20),
          new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        trunk.position.y = 4;

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(12, 20, 20),
          new THREE.MeshStandardMaterial({ color: 0x228B22 })
        );
        leaves.position.y = 24;

        tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
      }

      if (type === 2) {
        // Tree2 - th√¢n m·∫£nh, t√°n nh·ªè
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.7, 0.7, 6, 8),
          new THREE.MeshStandardMaterial({ color: 0x5C4033 })
        );
        trunk.position.y = 3;

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(12, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0x2E8B57 })
        );
        leaves.position.y = 8;

        tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
      }

      if (type === 3) {
        // Tree3 - th√¢n to, t√°n to
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(9, 12, 70, 70),
          new THREE.MeshStandardMaterial({ color: 0x4B3621 })
        );
        trunk.position.y = 5;

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(30, 40, 40),
          new THREE.MeshStandardMaterial({ color: 0x006400 })
        );
        leaves.position.y = 60;

        tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
      }

      if (type === 4) {
        // Tree4 - c√¢y th√¥ng (cone)
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(5, 5, 30, 30),
          new THREE.MeshStandardMaterial({ color: 0x8B5A2B })
        );
        trunk.position.y = 3;

        const leaves = new THREE.Mesh(
          new THREE.ConeGeometry(10, 26, 8),
          new THREE.MeshStandardMaterial({ color: 0x228B22 })
        );
        leaves.position.y = 20;

        tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
      }

      tree.position.set(x, 0, z);
      scene.add(tree);
    }

    // ====== 50 c√¢y v·ªõi 4 lo·∫°i ·ªü v·ªã tr√≠ c·ªë ƒë·ªãnh ======
    const treeLayout = [
      { type: 1, x: -450, z: -450 },
      { type: 2, x: -350, z: -400 },
      { type: 3, x: -250, z: -420 },
      { type: 4, x: -150, z: -380 },
      { type: 1, x:  -50, z: -440 },
      { type: 2, x:   50, z: -400 },
      { type: 3, x:  150, z: -420 },
      { type: 4, x:  250, z: -380 },
      { type: 1, x:  350, z: -450 },
      { type: 2, x:  450, z: -400 },

      { type: 3, x: -450, z: -250 },
      { type: 4, x: -350, z: -200 },
      { type: 1, x: -250, z: -220 },
      { type: 2, x: -150, z: -180 },
      { type: 3, x:  -50, z: -240 },
      { type: 4, x:   50, z: -200 },
      { type: 1, x:  150, z: -220 },
      { type: 2, x:  250, z: -180 },
      { type: 3, x:  350, z: -250 },
      { type: 4, x:  450, z: -200 },

      { type: 1, x: -450, z:   0 },
      { type: 2, x: -350, z:   50 },
      { type: 3, x: -250, z:  -30 },
      { type: 4, x: -150, z:   80 },
      { type: 1, x:  -50, z:   40 },
      { type: 2, x:   50, z:   60 },
      { type: 3, x:  150, z:  -20 },
      { type: 4, x:  250, z:   90 },
      { type: 1, x:  350, z:   40 },
      { type: 2, x:  450, z:   60 },

      { type: 3, x: -450, z:  250 },
      { type: 4, x: -350, z:  200 },
      { type: 1, x: -250, z:  220 },
      { type: 2, x: -150, z:  180 },
      { type: 3, x:  -50, z:  240 },
      { type: 4, x:   50, z:  200 },
      { type: 1, x:  150, z:  220 },
      { type: 2, x:  250, z:  180 },
      { type: 3, x:  350, z:  250 },
      { type: 4, x:  450, z:  200 },

      { type: 1, x: -450, z:  450 },
      { type: 2, x: -350, z:  400 },
      { type: 3, x: -250, z:  420 },
      { type: 4, x: -150, z:  380 },
      { type: 1, x:  -50, z:  440 },
      { type: 2, x:   50, z:  400 },
      { type: 3, x:  150, z:  420 },
      { type: 4, x:  250, z:  380 },
      { type: 1, x:  350, z:  450 },
      { type: 2, x:  450, z:  400 },
    ];

    // Th√™m c√¢y v√†o map
    for (const t of treeLayout) {
      createTree(t.type, t.x, t.z);
    }

    // ====== H√†m t·∫°o c√°c ki·ªÉu nh√† kh√°c nhau ======
    function createHouse(x, z){
      const bodyGeo = new THREE.BoxGeometry(40, 30, 40);
      const bodyMat = new THREE.MeshStandardMaterial({color: 0xffd27f});
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(x, 15, z);
      body.castShadow = true;

      const roofGeo = new THREE.ConeGeometry(30, 20, 4);
      const roofMat = new THREE.MeshStandardMaterial({color: 0x8b0000});
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.set(x, 40, z);
      roof.rotation.y = Math.PI/4;
      roof.castShadow = true;

      scene.add(body);
      scene.add(roof);
    }

    // T·∫°o nh√† c√≥ s·ªë v√† l∆∞u v·ªã tr√≠
    function createNumberedHouse(x, z, num){
      // Ch·ªçn ki·ªÉu nh√† d·ª±a tr√™n s·ªë nh√†
      const houseType = (num % 5) + 1; // 5 ki·ªÉu nh√†
      
      let house;
      
      switch(houseType) {
        case 1:
          // Ki·ªÉu 1: Nh√† g·ªó truy·ªÅn th·ªëng
          const body1 = new THREE.Mesh(
            new THREE.BoxGeometry(40, 30, 40),
            new THREE.MeshStandardMaterial({color: 0xffd27f})
          );
          body1.position.set(x, 15, z);
          body1.castShadow = true;

          const roof1 = new THREE.Mesh(
            new THREE.ConeGeometry(30, 20, 4),
            new THREE.MeshStandardMaterial({color: 0x8b0000})
          );
          roof1.position.set(x, 40, z);
          roof1.rotation.y = Math.PI/4;
          roof1.castShadow = true;

          house = new THREE.Group();
          house.add(body1);
          house.add(roof1);
          break;
          
        case 2:
          // Ki·ªÉu 2: Nh√† hi·ªán ƒë·∫°i
          const body2 = new THREE.Mesh(
            new THREE.BoxGeometry(40, 40, 40),
            new THREE.MeshStandardMaterial({color: 0xf0f0f0})
          );
          body2.position.set(x, 20, z);
          body2.castShadow = true;

          const roof2 = new THREE.Mesh(
            new THREE.BoxGeometry(45, 5, 45),
            new THREE.MeshStandardMaterial({color: 0x606060})
          );
          roof2.position.set(x, 42.5, z);
          roof2.castShadow = true;

          // C·ª≠a s·ªï
          const windowGeo = new THREE.BoxGeometry(8, 8, 1);
          const windowMat = new THREE.MeshStandardMaterial({color: 0x87ceeb});
          
          for (let i = 0; i < 4; i++) {
            const window = new THREE.Mesh(windowGeo, windowMat);
            window.position.set(
              x + (i % 2 === 0 ? -12 : 12),
              25,
              z + (i < 2 ? -18 : 18)
            );
            house = house || new THREE.Group();
            house.add(window);
          }

          house = house || new THREE.Group();
          house.add(body2);
          house.add(roof2);
          break;
          
        case 3:
          // Ki·ªÉu 3: Nh√† ·ªëng
          const body3 = new THREE.Mesh(
            new THREE.BoxGeometry(25, 50, 40),
            new THREE.MeshStandardMaterial({color: 0xffcc99})
          );
          body3.position.set(x, 25, z);
          body3.castShadow = true;

          const roof3 = new THREE.Mesh(
            new THREE.ConeGeometry(20, 15, 4),
            new THREE.MeshStandardMaterial({color: 0x663300})
          );
          roof3.position.set(x, 57.5, z);
          roof3.rotation.y = Math.PI/4;
          roof3.castShadow = true;

          house = new THREE.Group();
          house.add(body3);
          house.add(roof3);
          break;
          
        case 4:
          // Ki·ªÉu 4: Nh√† l·∫ßu
          // T·∫ßng 1
          const floor1 = new THREE.Mesh(
            new THREE.BoxGeometry(40, 25, 40),
            new THREE.MeshStandardMaterial({color: 0xe6e6e6})
          );
          floor1.position.set(x, 12.5, z);
          floor1.castShadow = true;

          // T·∫ßng 2
          const floor2 = new THREE.Mesh(
            new THREE.BoxGeometry(35, 25, 35),
            new THREE.MeshStandardMaterial({color: 0xf5f5f5})
          );
          floor2.position.set(x, 37.5, z);
          floor2.castShadow = true;

          // M√°i
          const roof4 = new THREE.Mesh(
            new THREE.ConeGeometry(25, 15, 4),
            new THREE.MeshStandardMaterial({color: 0x8b4513})
          );
          roof4.position.set(x, 57.5, z);
          roof4.rotation.y = Math.PI/4;
          roof4.castShadow = true;

          house = new THREE.Group();
          house.add(floor1);
          house.add(floor2);
          house.add(roof4);
          break;
          
        case 5:
          // Ki·ªÉu 5: Nh√† m√°i b·∫±ng
          const body5 = new THREE.Mesh(
            new THREE.BoxGeometry(40, 30, 40),
            new THREE.MeshStandardMaterial({color: 0xd9b38c})
          );
          body5.position.set(x, 15, z);
          body5.castShadow = true;

          const roof5 = new THREE.Mesh(
            new THREE.BoxGeometry(42, 2, 42),
            new THREE.MeshStandardMaterial({color: 0x666666})
          );
          roof5.position.set(x, 31, z);
          roof5.castShadow = true;

          // H√†ng r√†o
          const fenceGeo = new THREE.BoxGeometry(50, 5, 50);
          const fenceMat = new THREE.MeshStandardMaterial({color: 0x8b4513});
          const fence = new THREE.Mesh(fenceGeo, fenceMat);
          fence.position.set(x, 2.5, z);
          
          house = new THREE.Group();
          house.add(body5);
          house.add(roof5);
          house.add(fence);
          break;
      }

      scene.add(house);

      // Label s·ªë (canvas) ‚Äî n·ªÅn trong su·ªët
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,128,128);
      // optional small white rounded bg for readability:
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.beginPath();
      ctx.rect(8,8,112,112);
      ctx.fill();

      ctx.fillStyle = '#000000';
      ctx.font = 'bold 80px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(num), 64, 64);

      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      const labelMat = new THREE.MeshBasicMaterial({map: tex, transparent: true});
      const labelGeo = new THREE.PlaneGeometry(20,20);
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.position.set(x, 25, z + 30); // ƒë·∫∑t tr∆∞·ªõc nh√†
      label.rotation.y = 0;

      scene.add(label);

      housePositions.push(new THREE.Vector3(x, 0, z)); // l∆∞u v·ªã tr√≠ (y=0 d√πng cho ki·ªÉm tra XZ)
    }

    function createRoad(x, z, length=200, width=20){
      const roadGeo = new THREE.BoxGeometry(width, 1, length);
      const roadMat = new THREE.MeshStandardMaterial({color: 0x333333});
      const road = new THREE.Mesh(roadGeo, roadMat);
      road.position.set(x, 0.5, z);
      road.receiveShadow = true;
      scene.add(road);
    }

    // T·∫°o 25 cƒÉn nh√† v·ªõi v·ªã tr√≠ c·ªë ƒë·ªãnh
    const houseLayout = [
      {num: 1, x: -400, z: -400},
      {num: 2, x: -200, z: -400},
      {num: 3, x:   0,  z: -400},
      {num: 4, x:  200, z: -400},
      {num: 5, x:  400, z: -400},

      {num: 6, x: -400, z: -200},
      {num: 7, x: -200, z: -200},
      {num: 8, x:   0,  z: -200},
      {num: 9, x:  200, z: -200},
      {num:10, x:  400, z: -200},

      {num:11, x: -400, z:   0},
      {num:12, x: -200, z:   0},
      {num:13, x:   0,  z:   0},
      {num:14, x:  200, z:   0},
      {num:15, x:  400, z:   0},

      {num:16, x: -400, z: 200},
      {num:17, x: -200, z: 200},
      {num:18, x:   0,  z: 200},
      {num:19, x:  200, z: 200},
      {num:20, x:  400, z: 200},

      {num:21, x: -400, z: 400},
      {num:22, x: -200, z: 400},
      {num:23, x:   0,  z: 400},
      {num:24, x:  200, z: 400},
      {num:25, x:  400, z: 400},
    ];

    for(const h of houseLayout){
      createNumberedHouse(h.x, h.z, h.num);
    }

    // ------- Car -------
    let inCar = false;


    /*function createCar(x, z){
      const group = new THREE.Group();

      const bodyGeo = new THREE.BoxGeometry(20, 15, 40);
      const bodyMat = new THREE.MeshStandardMaterial({color: 0xff0000});
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 10;
      body.castShadow = true;
      group.add(body);

      const topGeo = new THREE.BoxGeometry(20, 10, 18);
      const topMat = new THREE.MeshStandardMaterial({color: 0x990000});
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.set(0, 18, 0);
      group.add(top);

      const wheelGeo = new THREE.CylinderGeometry(5, 5, 4, 16);
      const wheelMat = new THREE.MeshStandardMaterial({color: 0x000000});
      for(let dx of [-9, 9]){ // nh·ªè l·∫°i cho t·ªâ l·ªá ·ªïn
        for(let dz of [-15, 15]){
          const wheel = new THREE.Mesh(wheelGeo, wheelMat);
          wheel.rotation.z = Math.PI/2;
          wheel.position.set(dx, 5, dz);
          group.add(wheel);
        }
      }

      group.position.set(x, 0, z);
      scene.add(group);
      return group;
    }

    */


    
    function createCar(x, z){
  const loader = new GLTFLoader();
  const group = new THREE.Group();

  loader.load('car.glb', (gltf)=>{
    const model = gltf.scene;
    model.scale.set(10,10,10); // ch·ªânh t·ªâ l·ªá n·∫øu c·∫ßn
    model.position.set(0,0,0); // v·ªã tr√≠ relative trong group
    model.traverse((child)=>{
      if(child.isMesh){
        child.castShadow = true;
      }
    });
    group.add(model);
  }, undefined, (err)=>{
    console.error('L·ªói load xe:', err);
  });

  group.position.set(x, 0, z);
  scene.add(group);
  return group;
}


    // ------- Fuel system -------
    let fuel = 100;          // nhi√™n li·ªáu xe
    const maxFuel = 100;
    const fuelDiv = document.createElement('div');
    fuelDiv.className = "info";
    fuelDiv.style.top = "120px";
    document.body.appendChild(fuelDiv);

    function updateFuelText(){
      fuelDiv.innerText = `Nhi√™n li·ªáu: ${fuel.toFixed(0)} / ${maxFuel}`;
    }
    updateFuelText();

    // gi·∫£m nhi√™n li·ªáu khi l√°i xe
    function consumeFuel(dt){
      if(inCar && fuel > 0){
        fuel -= dt * 5; // hao nhanh/ch·∫≠m t√πy ch·ªânh
        if(fuel < 0) fuel = 0;
        updateFuelText();
      }
    }

    // ------- Gas Station -------
    function createGasStation(x, z){
      const baseGeo = new THREE.BoxGeometry(60, 20, 40);
      const baseMat = new THREE.MeshStandardMaterial({color:0x999999});
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(x, 10, z);
      base.castShadow = true;
      scene.add(base);

      // bi·ªÉn hi·ªáu GAS
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'yellow';
      ctx.fillRect(0,0,256,128);
      ctx.fillStyle = 'black';
      ctx.font = 'bold 80px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText("GAS", 128, 64);
      const tex = new THREE.CanvasTexture(canvas);
      const signMat = new THREE.MeshBasicMaterial({map: tex});
      const signGeo = new THREE.PlaneGeometry(50, 25);
      const sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(x, 40, z);
      scene.add(sign);

      return base;
    }

    const gasStation = createGasStation(100, -50);

    // ph√≠m R ƒë·ªÉ n·∫°p nhi√™n li·ªáu khi g·∫ßn tr·∫°m xƒÉng
    window.addEventListener('keydown', e=>{
      if(e.key.toLowerCase() === 'r'){
        const target = inCar ? car : player;
        const dist = distanceXZ(target.position, gasStation.position);
        if(dist < 60){
          fuel = maxFuel;
          updateFuelText();
          console.log("ƒê√£ n·∫°p ƒë·∫ßy nhi√™n li·ªáu!");
        }
      }
    });

    // ------- NPC moving cars/people -------
    const npcs = [];

    function createNPC(x, z, color=0x00ff00){
      const geo = new THREE.BoxGeometry(10, 20, 10);
      const mat = new THREE.MeshStandardMaterial({color});
      const npc = new THREE.Mesh(geo, mat);
      npc.position.set(x, 10, z);
      scene.add(npc);
      npcs.push({mesh: npc, dir: 1});
    }

   

    // NPC logic: di chuy·ªÉn qua l·∫°i
    function updateNPCs(dt){
      for(const n of npcs){
        n.mesh.position.x += n.dir * dt * 50; // t·ªëc ƒë·ªô 50
        if(n.mesh.position.x > 300) n.dir = -1;
        if(n.mesh.position.x < -300) n.dir = 1;
      }
    }

    const car = createCar(100, 0);

    // ------- Cargo visual -------
    const cargoGeo = new THREE.BoxGeometry(10,6,8);
    const cargoMat = new THREE.MeshStandardMaterial({color:0xffcc00});
    const cargoMesh = new THREE.Mesh(cargoGeo, cargoMat);
    cargoMesh.castShadow = true;
    cargoMesh.visible = false;
    scene.add(cargoMesh);

    // ------- Input: enter/exit car, G to pickup/drop -------
    window.addEventListener('keydown', e=>{
      const k = e.key.toLowerCase();

      // Enter / exit car (E)
      if(k === 'e'){
        // d√πng kho·∫£ng c√°ch XZ ƒë·ªÉ t√≠nh
        const distToCar = distanceXZ(player.position, car.position);
        if(!inCar && distToCar < 30){
          inCar = true;
          player.visible = false;
          // khi l√™n xe, ƒë·∫∑t player v·ªã tr√≠ g·∫ßn xe (unused) - cargo s·∫Ω g·∫Øn theo car n·∫øu hasCargo
          console.log("ƒê√£ l√™n xe!");
          updateMissionText();
        } else if(inCar){
          inCar = false;
          player.visible = true;
          player.position.copy(car.position).add(new THREE.Vector3(0,10,20)); // Xu·ªëng c·∫°nh xe
          console.log("ƒê√£ xu·ªëng xe!");
          updateMissionText();
        }
      }

      // G: l·∫•y/giao h√†ng
      if(k === 'g'){
        const target = inCar ? car : player;

        const distPickup = distanceXZ(target.position, housePositions[currentPickup-1]);
        const distDrop = distanceXZ(target.position, housePositions[currentDrop-1]);

        if(!hasCargo && distPickup < 40){
          hasCargo = true;
          cargoMesh.visible = true;
          console.log(`ƒê√£ l·∫•y h√†ng t·∫°i nh√† ${currentPickup}`);
          updateMissionText();
        } else if(hasCargo && distDrop < 40){
          hasCargo = false;
          cargoMesh.visible = false;
          coins += 50;
          console.log(`ƒê√£ giao h√†ng t·∫°i nh√† ${currentDrop}, +50 xu`);
          newMission(currentDrop);
        } else {
          // optional feedback
          // console.log('Kh√¥ng ·ªü ƒë√∫ng v·ªã tr√≠ l·∫•y/giao');
        }
      }
    });

    // ------- Camera init -------
    (function initCamera(){
      const target = inCar ? car : player;
      const hDist = followDistance;
      const y = hDist * Math.tan(tiltRad);
      const camPos = new THREE.Vector3(target.position.x, target.position.y + y, target.position.z + hDist);
      camera.position.copy(camPos);
      camera.lookAt(target.position.x, target.position.y + 10, target.position.z);
    })();

    updateMissionText(); // hi·ªÉn th·ªã ban ƒë·∫ßu

    // ------- Main animate -------
    function animate(){
      const dt = Math.min(0.05, clock.getDelta());

      let dirX=0, dirZ=0;
      if(keys.w) dirZ -= 1;
      if(keys.s) dirZ += 1;
      if(keys.a) dirX -= 1;
      if(keys.d) dirX += 1;

      const running = keys.shift;
      const baseSpeed = walkSpeed * (running ? runMultiplier : 1);
      const speed = baseSpeed * (inCar ? 2 : 1); // üöó t·ªëc ƒë·ªô x3 khi trong xe
      const len = Math.hypot(dirX, dirZ);
      if(len>0){ dirX/=len; dirZ/=len; }

      if(len > 0){
        if(inCar){
          if(len > 0.001){
            // camera axes
            const camForward = new THREE.Vector3();
            camera.getWorldDirection(camForward);
            camForward.y = 0;
            camForward.normalize();
            const up = new THREE.Vector3(0,1,0);
            const camRight = new THREE.Vector3().crossVectors(camForward, up).normalize();

            // map input -> world direction
            const inputWorld = new THREE.Vector3();
            inputWorld.copy(camRight).multiplyScalar(dirX).add(camForward.clone().multiplyScalar(-dirZ));
            if(inputWorld.length() < 0.0001) return;
            inputWorld.normalize();

            // base desired (the "natural" angle from inputWorld)
            let desired = Math.atan2(inputWorld.x, -inputWorld.z);

            const baseForward = new THREE.Vector3(0,0,1); // ch·ªânh n·∫øu model m≈©i ko ph·∫£i -Z

            // --- diagonal handling: pick +90 or -90 so that forward aligns with inputWorld ---
            if(Math.abs(dirX) > 0.0001 && Math.abs(dirZ) > 0.0001){
              // propose two offsets
              const s = Math.sign(inputWorld.x || dirX); // h∆∞·ªõng ngang c·ªßa input (fallback dirX)
              const offsets = [ s * Math.PI/2, -s * Math.PI/2 ];

              // choose offset that makes candidateForward dot inputWorld > 0
              let picked = 0;
              for(let i=0;i<offsets.length;i++){
                const cand = desired + offsets[i];
                const testQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, cand, 0));
                const candidateForward = baseForward.clone().applyQuaternion(testQuat).normalize();
                const d = candidateForward.dot(inputWorld);
                if(d > 0.01){ // ch√∫t ng∆∞·ª°ng nh·ªè ƒë·ªÉ tr√°nh tr∆∞·ªùng h·ª£p s√°t bi√™n
                  picked = i;
                  break;
                }
                // n·∫øu c·∫£ hai ƒë·ªÅu <= 0.01 th√¨ v·∫´n gi·ªØ offsets[0] v√† ch√∫ng ta s·∫Ω x·ª≠ l√Ω ti·∫øp b√™n d∆∞·ªõi
              }
              desired += offsets[picked];
              // (kh√¥ng l√†m auto +PI n·ªØa v√¨ ta ƒë√£ th·ª≠ c·∫£ chi·ªÅu)
            } else {
              // not diagonal: keep existing guard to flip 180¬∞ if model forward is opposite
              const testQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, desired, 0));
              const candidateForward = baseForward.clone().applyQuaternion(testQuat).normalize();
              if(candidateForward.dot(inputWorld) < 0){
                desired += Math.PI;
              }
            }

            // slerp rotate and move by current forward
            const targetQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, desired, 0));
            car.quaternion.slerp(targetQuat, Math.min(1, 10 * dt));

            const forward = baseForward.clone().applyQuaternion(car.quaternion).normalize();
            const moveAmount = speed * (60 * dt) * len;
            car.position.add(forward.multiplyScalar(moveAmount));
          }
        }
        else {
          player.position.x += dirX * speed * (60*dt);
          player.position.z += dirZ * speed * (60*dt);
          player.rotation.y = Math.atan2(dirX, -dirZ);
        }
      }

      // Jump physics for player (only when not in car)
      if(!inCar){
        if(keys.space && onGround){ verticalVel = jumpSpeed; onGround=false; }
        if(!onGround){ verticalVel += gravity*(60*dt); player.position.y += verticalVel*(60*dt);
          if(player.position.y <= playerSize){ player.position.y = playerSize; verticalVel=0; onGround=true; }
        }
      } else {
        // n·∫øu ·ªü trong xe, fix y
        player.position.y = playerSize;
      }

      // Gi·ªõi h·∫°n trong map cho c·∫£ player v√† car
      const halfMap = 500 - 10;
      player.position.x = Math.max(-halfMap, Math.min(halfMap, player.position.x));
      player.position.z = Math.max(-halfMap, Math.min(halfMap, player.position.z));
      car.position.x = Math.max(-halfMap, Math.min(halfMap, car.position.x));
      car.position.z = Math.max(-halfMap, Math.min(halfMap, car.position.z));

      // C·∫≠p nh·∫≠t cargo position n·∫øu ƒëang c·∫ßm
      if(hasCargo){
        if(inCar){
          cargoMesh.position.copy(car.position).add(new THREE.Vector3(0, 18, 0));
        } else {
          cargoMesh.position.copy(player.position).add(new THREE.Vector3(0, 12, 0));
        }
        cargoMesh.visible = true;
      } else {
        cargoMesh.visible = false;
      }

      // Camera follow target (player ho·∫∑c xe)
      const target = inCar ? car : player;
      const hDist = followDistance;
      const y = hDist * Math.tan(tiltRad);
      const camPos = new THREE.Vector3(target.position.x, target.position.y + y, target.position.z + hDist);

      camera.position.lerp(camPos, 1); // m∆∞·ª£t h∆°n
      camera.lookAt(target.position.x, target.position.y + 10, target.position.z);

      // C·∫≠p nh·∫≠t th√¥ng tin nh√† g·∫ßn nh·∫•t
      updateNearestHouseInfo();

      // Update mission UI (in case coins/hasCargo changed)
      updateMissionText();
      updateNPCs(dt);
      consumeFuel(dt);

      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }

    // H√†m c·∫≠p nh·∫≠t th√¥ng tin nh√† g·∫ßn nh·∫•t
    function updateNearestHouseInfo() {
      const target = inCar ? car : player;
      let nearestHouse = null;
      let minDistance = Infinity;
      
      for (let i = 0; i < housePositions.length; i++) {
        const dist = distanceXZ(target.position, housePositions[i]);
        if (dist < minDistance) {
          minDistance = dist;
          nearestHouse = i + 1;
        }
      }
      
      if (nearestHouse && minDistance < 100) {
        houseInfoDiv.innerText = `Nh√† g·∫ßn nh·∫•t: ${nearestHouse}\nKho·∫£ng c√°ch: ${minDistance.toFixed(1)}m`;
      } else {
        houseInfoDiv.innerText = '';
      }
    }

    animate();
    document.body.addEventListener('click', ()=>{window.focus();});
  </script>
</body>
</html>
