<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Plane 1000x1000 - Delivery Missions</title>
  <style>
    html,body{height:100%;margin:0}
    #app{width:100%;height:100%;display:block;overflow:hidden}
    .info{position:fixed;left:10px;top:10px;background:rgba(0,0,0,0.6);color:#fff;padding:8px;border-radius:6px;font-family:sans-serif;white-space:pre-line}
    .mission{top:60px;left:10px}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="info">WASD để di chuyển — Space nhảy (nhỏ) — Shift chạy — E lên/xuống xe — G lấy/giao hàng</div>

  <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

  <script type="module">
    
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0a0a0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('app').appendChild(renderer.domElement);

    const planeGeo = new THREE.PlaneGeometry(1000, 1000, 50, 50);
    const planeMat = new THREE.MeshStandardMaterial({color:0x808080, side:THREE.DoubleSide, roughness:0.9});
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI/2;
    plane.receiveShadow = true;
    scene.add(plane);

    const grid = new THREE.GridHelper(1000, 20, 0x444444, 0x888888);
    scene.add(grid);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0,200,0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(100,300,200);
    dir.castShadow = true;
    dir.shadow.camera.left = -500; dir.shadow.camera.right = 500;
    dir.shadow.camera.top = 500; dir.shadow.camera.bottom = -500;
    dir.shadow.mapSize.set(2048,2048);
    scene.add(dir);

    const playerSize = 10;
    const playerGeo = new THREE.BoxGeometry(playerSize, playerSize*2, playerSize);
    const playerMat = new THREE.MeshStandardMaterial({color:0x0099ff});
    const player = new THREE.Mesh(playerGeo, playerMat);
    player.castShadow = true;
    player.position.set(0, playerSize, 0);
    scene.add(player);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);

    const tiltRad = Math.PI/4;
    const followDistance = 200;

    const keys = {w:false,a:false,s:false,d:false,shift:false,space:false};
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if(k in keys) keys[k]=true;
    });
    window.addEventListener('keyup', e => {
      const k = e.key.toLowerCase();
      if(k in keys) keys[k]=false;
    });

    const walkSpeed = 0.4;
    const runMultiplier = 2.0;
    let verticalVel = 0;
    const gravity = -1.2;
    const jumpSpeed = 18;
    let onGround = true;

    const half = 500 - 10;

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const clock = new THREE.Clock();

    // ------- Mission & houses data -------
    const housePositions = []; // lưu tọa độ các nhà
    let currentPickup = 1;   // Nhà lấy hàng
    let currentDrop = 2;     // Nhà giao hàng
    let hasCargo = false;    // Đang cầm hàng hay không
    let coins = 0;           // Xu hiện tại

    // UI nhiệm vụ
    const missionDiv = document.createElement('div');
    missionDiv.className = "info mission";
    missionDiv.style.top = "60px";
    missionDiv.innerText = '';
    document.body.appendChild(missionDiv);

    function updateMissionText(){
      const txt = hasCargo 
        ? `Đang giữ hàng, giao đến nhà ${currentDrop}` 
        : `Hãy lấy hàng ở nhà ${currentPickup}`;
      missionDiv.innerText = `Nhiệm vụ: ${txt}\nXu: ${coins}`;
    }

    function newMission(start){
      currentPickup = start;
      currentDrop = (start % 25) + 1; // sau nhà 25 là nhà 1
      hasCargo = false;
      updateMissionText();
    }

    // tiện ích khoảng cách theo XZ (2D)
    function distanceXZ(a, b){
      return Math.hypot(a.x - b.x, a.z - b.z);
    }

    // ------- Environment creators -------
    // ====== Hàm tạo nhiều loại cây ======
    function createTree(type, x, z) {
      let tree;
      if (type === 1) {
        // Tree1 - thân trụ, tán cầu
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(4, 6, 60, 20),
          new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        trunk.position.y = 4;

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(12, 20, 20),
          new THREE.MeshStandardMaterial({ color: 0x228B22 })
        );
        leaves.position.y = 24;

        tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
      }

      if (type === 2) {
        // Tree2 - thân mảnh, tán nhỏ
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.7, 0.7, 6, 8),
          new THREE.MeshStandardMaterial({ color: 0x5C4033 })
        );
        trunk.position.y = 3;

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(12, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0x2E8B57 })
        );
        leaves.position.y = 8;

        tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
      }

      if (type === 3) {
        // Tree3 - thân to, tán to
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(9, 12, 70, 70),
          new THREE.MeshStandardMaterial({ color: 0x4B3621 })
        );
        trunk.position.y = 5;

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(30, 40, 40),
          new THREE.MeshStandardMaterial({ color: 0x006400 })
        );
        leaves.position.y = 60;

        tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
      }

      if (type === 4) {
        // Tree4 - cây thông (cone)
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(5, 5, 30, 30),
          new THREE.MeshStandardMaterial({ color: 0x8B5A2B })
        );
        trunk.position.y = 3;

        const leaves = new THREE.Mesh(
          new THREE.ConeGeometry(10, 26, 8),
          new THREE.MeshStandardMaterial({ color: 0x228B22 })
        );
        leaves.position.y = 20;

        tree = new THREE.Group();
        tree.add(trunk);
        tree.add(leaves);
      }

      tree.position.set(x, 0, z);
      scene.add(tree);
    }

    // ====== 50 cây với 4 loại ở vị trí cố định ======
    const treeLayout = [
      { type: 1, x: -450, z: -450 },
      { type: 2, x: -350, z: -400 },
      { type: 3, x: -250, z: -420 },
      { type: 4, x: -150, z: -380 },
      { type: 1, x:  -50, z: -440 },
      { type: 2, x:   50, z: -400 },
      { type: 3, x:  150, z: -420 },
      { type: 4, x:  250, z: -380 },
      { type: 1, x:  350, z: -450 },
      { type: 2, x:  450, z: -400 },

      { type: 3, x: -450, z: -250 },
      { type: 4, x: -350, z: -200 },
      { type: 1, x: -250, z: -220 },
      { type: 2, x: -150, z: -180 },
      { type: 3, x:  -50, z: -240 },
      { type: 4, x:   50, z: -200 },
      { type: 1, x:  150, z: -220 },
      { type: 2, x:  250, z: -180 },
      { type: 3, x:  350, z: -250 },
      { type: 4, x:  450, z: -200 },

      { type: 1, x: -450, z:   0 },
      { type: 2, x: -350, z:   50 },
      { type: 3, x: -250, z:  -30 },
      { type: 4, x: -150, z:   80 },
      { type: 1, x:  -50, z:   40 },
      { type: 2, x:   50, z:   60 },
      { type: 3, x:  150, z:  -20 },
      { type: 4, x:  250, z:   90 },
      { type: 1, x:  350, z:   40 },
      { type: 2, x:  450, z:   60 },

      { type: 3, x: -450, z:  250 },
      { type: 4, x: -350, z:  200 },
      { type: 1, x: -250, z:  220 },
      { type: 2, x: -150, z:  180 },
      { type: 3, x:  -50, z:  240 },
      { type: 4, x:   50, z:  200 },
      { type: 1, x:  150, z:  220 },
      { type: 2, x:  250, z:  180 },
      { type: 3, x:  350, z:  250 },
      { type: 4, x:  450, z:  200 },

      { type: 1, x: -450, z:  450 },
      { type: 2, x: -350, z:  400 },
      { type: 3, x: -250, z:  420 },
      { type: 4, x: -150, z:  380 },
      { type: 1, x:  -50, z:  440 },
      { type: 2, x:   50, z:  400 },
      { type: 3, x:  150, z:  420 },
      { type: 4, x:  250, z:  380 },
      { type: 1, x:  350, z:  450 },
      { type: 2, x:  450, z:  400 },
    ];

    // Thêm cây vào map
    for (const t of treeLayout) {
      createTree(t.type, t.x, t.z);
    }

    // Tạo nhà có số và lưu vị trí
    function createNumberedHouse(x, z, num){
      // Chọn kiểu nhà dựa trên số nhà
      const houseType = (num % 5) + 1; // 5 kiểu nhà
      
      let house;
      
      switch(houseType) {
        case 1:
          // Kiểu 1: Nhà gỗ truyền thống
          const body1 = new THREE.Mesh(
            new THREE.BoxGeometry(40, 30, 40),
            new THREE.MeshStandardMaterial({color: 0xffd27f})
          );
          body1.position.set(x, 15, z);
          body1.castShadow = true;

          const roof1 = new THREE.Mesh(
            new THREE.ConeGeometry(30, 20, 4),
            new THREE.MeshStandardMaterial({color: 0x8b0000})
          );
          roof1.position.set(x, 40, z);
          roof1.rotation.y = Math.PI/4;
          roof1.castShadow = true;

          house = new THREE.Group();
          house.add(body1);
          house.add(roof1);
          break;
          
        case 2:
          // Kiểu 2: Nhà hiện đại
          const body2 = new THREE.Mesh(
            new THREE.BoxGeometry(40, 40, 40),
            new THREE.MeshStandardMaterial({color: 0xf0f0f0})
          );
          body2.position.set(x, 20, z);
          body2.castShadow = true;

          const roof2 = new THREE.Mesh(
            new THREE.BoxGeometry(45, 5, 45),
            new THREE.MeshStandardMaterial({color: 0x606060})
          );
          roof2.position.set(x, 42.5, z);
          roof2.castShadow = true;

          house = new THREE.Group();
          house.add(body2);
          house.add(roof2);

          // Cửa sổ
          const windowGeo = new THREE.BoxGeometry(8, 8, 1);
          const windowMat = new THREE.MeshStandardMaterial({color: 0x87ceeb});
          
          for (let i = 0; i < 4; i++) {
            const window = new THREE.Mesh(windowGeo, windowMat);
            window.position.set(
              x + (i % 2 === 0 ? -12 : 12),
              25,
              z + (i < 2 ? -18 : 18)
            );
            house.add(window);
          }
          break;
          
        case 3:
          // Kiểu 3: Nhà ống
          const body3 = new THREE.Mesh(
            new THREE.BoxGeometry(25, 50, 40),
            new THREE.MeshStandardMaterial({color: 0xffcc99})
          );
          body3.position.set(x, 25, z);
          body3.castShadow = true;

          const roof3 = new THREE.Mesh(
            new THREE.ConeGeometry(20, 15, 4),
            new THREE.MeshStandardMaterial({color: 0x663300})
          );
          roof3.position.set(x, 57.5, z);
          roof3.rotation.y = Math.PI/4;
          roof3.castShadow = true;

          house = new THREE.Group();
          house.add(body3);
          house.add(roof3);
          break;
          
        case 4:
          // Kiểu 4: Nhà lầu
          // Tầng 1
          const floor1 = new THREE.Mesh(
            new THREE.BoxGeometry(40, 25, 40),
            new THREE.MeshStandardMaterial({color: 0xe6e6e6})
          );
          floor1.position.set(x, 12.5, z);
          floor1.castShadow = true;

          // Tầng 2
          const floor2 = new THREE.Mesh(
            new THREE.BoxGeometry(35, 25, 35),
            new THREE.MeshStandardMaterial({color: 0xf5f5f5})
          );
          floor2.position.set(x, 37.5, z);
          floor2.castShadow = true;

          // Mái
          const roof4 = new THREE.Mesh(
            new THREE.ConeGeometry(25, 15, 4),
            new THREE.MeshStandardMaterial({color: 0x8b4513})
          );
          roof4.position.set(x, 57.5, z);
          roof4.rotation.y = Math.PI/4;
          roof4.castShadow = true;

          house = new THREE.Group();
          house.add(floor1);
          house.add(floor2);
          house.add(roof4);
          break;
          
        case 5:
          // Kiểu 5: Nhà mái bằng
          const body5 = new THREE.Mesh(
            new THREE.BoxGeometry(40, 30, 40),
            new THREE.MeshStandardMaterial({color: 0xd9b38c})
          );
          body5.position.set(x, 15, z);
          body5.castShadow = true;

          const roof5 = new THREE.Mesh(
            new THREE.BoxGeometry(42, 2, 42),
            new THREE.MeshStandardMaterial({color: 0x666666})
          );
          roof5.position.set(x, 31, z);
          roof5.castShadow = true;

          // Hàng rào
          const fenceGeo = new THREE.BoxGeometry(50, 5, 50);
          const fenceMat = new THREE.MeshStandardMaterial({color: 0x8b4513});
          const fence = new THREE.Mesh(fenceGeo, fenceMat);
          fence.position.set(x, 2.5, z);
          
          house = new THREE.Group();
          house.add(body5);
          house.add(roof5);
          house.add(fence);
          break;
      }

      scene.add(house);

      // Label số (canvas) — nền trong suốt
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,128,128);
      // optional small white rounded bg for readability:
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.beginPath();
      ctx.rect(8,8,112,112);
      ctx.fill();

      ctx.fillStyle = '#000000';
      ctx.font = 'bold 80px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(num), 64, 64);

      const tex = new THREE.CanvasTexture(canvas);
      const labelMat = new THREE.MeshBasicMaterial({map: tex, transparent: true});
      const labelGeo = new THREE.PlaneGeometry(20,20);
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.position.set(x, 25, z + 30); // đặt trước nhà
      label.rotation.y = 0;

      scene.add(label);

      housePositions.push(new THREE.Vector3(x, 0, z)); // lưu vị trí (y=0 dùng cho kiểm tra XZ)
    }

    // Tạo 25 căn nhà với vị trí cố định
    const houseLayout = [
      {num: 1, x: -400, z: -400},
      {num: 2, x: -200, z: -400},
      {num: 3, x:   0,  z: -400},
      {num: 4, x:  200, z: -400},
      {num: 5, x:  400, z: -400},

      {num: 6, x: -400, z: -200},
      {num: 7, x: -200, z: -200},
      {num: 8, x:   0,  z: -200},
      {num: 9, x:  200, z: -200},
      {num:10, x:  400, z: -200},

      {num:11, x: -400, z:   0},
      {num:12, x: -200, z:   0},
      {num:13, x:   0,  z:   0},
      {num:14, x:  200, z:   0},
      {num:15, x:  400, z:   0},

      {num:16, x: -400, z: 200},
      {num:17, x: -200, z: 200},
      {num:18, x:   0,  z: 200},
      {num:19, x:  200, z: 200},
      {num:20, x:  400, z: 200},

      {num:21, x: -400, z: 400},
      {num:22, x: -200, z: 400},
      {num:23, x:   0,  z: 400},
      {num:24, x:  200, z: 400},
      {num:25, x:  400, z: 400},
    ];

    for(const h of houseLayout){
      createNumberedHouse(h.x, h.z, h.num);
    }

    // ------- Car -------
    let inCar = false;
    function createCar(x, z){
      const loader = new GLTFLoader();
      const group = new THREE.Group();

      loader.load('car.glb', (gltf)=>{
        const model = gltf.scene;
        model.scale.set(10,10,10);
        model.position.set(0,0,0);
        model.traverse((child)=>{
          if(child.isMesh){
            child.castShadow = true;
          }
        });
        group.add(model);
      }, undefined, (err)=>{
        console.error('Lỗi load xe:', err);
        // Fallback: tạo xe đơn giản nếu không load được file .glb
        const bodyGeo = new THREE.BoxGeometry(30, 15, 60);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 7.5;
        body.castShadow = true;
        group.add(body);
        
        const cabinGeo = new THREE.BoxGeometry(25, 12, 25);
        const cabinMat = new THREE.MeshStandardMaterial({ color: 0x4444ff });
        const cabin = new THREE.Mesh(cabinGeo, cabinMat);
        cabin.position.set(0, 19, 10);
        cabin.castShadow = true;
        group.add(cabin);
      });

      group.position.set(x, 0, z);
      scene.add(group);
      return group;
    }

    // ------- Cargo visual -------
    const cargoGeo = new THREE.BoxGeometry(10,6,8);
    const cargoMat = new THREE.MeshStandardMaterial({color:0xffcc00});
    const cargoMesh = new THREE.Mesh(cargoGeo, cargoMat);
    cargoMesh.castShadow = true;
    cargoMesh.visible = false;
    scene.add(cargoMesh);

    // ------- Input: enter/exit car, G to pickup/drop -------
    window.addEventListener('keydown', e=>{
      const k = e.key.toLowerCase();

      // Enter / exit car (E)
      if(k === 'e'){
        // dùng khoảng cách XZ để tính
        const distToCar = distanceXZ(player.position, car.position);
        if(!inCar && distToCar < 30){
          inCar = true;
          player.visible = false;
          console.log("Đã lên xe!");
          updateMissionText();
        } else if(inCar){
          inCar = false;
          player.visible = true;
          player.position.copy(car.position).add(new THREE.Vector3(0,10,20)); // Xuống cạnh xe
          console.log("Đã xuống xe!");
          updateMissionText();
        }
      }

      // G: lấy/giao hàng
      if(k === 'g'){
        const target = inCar ? car : player;

        const distPickup = distanceXZ(target.position, housePositions[currentPickup-1]);
        const distDrop = distanceXZ(target.position, housePositions[currentDrop-1]);

        if(!hasCargo && distPickup < 40){
          hasCargo = true;
          cargoMesh.visible = true;
          console.log(`Đã lấy hàng tại nhà ${currentPickup}`);
          updateMissionText();
        } else if(hasCargo && distDrop < 40){
          hasCargo = false;
          cargoMesh.visible = false;
          coins += 50;
          console.log(`Đã giao hàng tại nhà ${currentDrop}, +50 xu`);
          newMission(currentDrop);
        }
      }
    });

    // Tạo xe
    const car = createCar(100, 0);

    // ------- Camera init -------
    (function initCamera(){
      const target = inCar ? car : player;
      const hDist = followDistance;
      const y = hDist * Math.tan(tiltRad);
      const camPos = new THREE.Vector3(target.position.x, target.position.y + y, target.position.z + hDist);
      camera.position.copy(camPos);
      camera.lookAt(target.position.x, target.position.y + 10, target.position.z);
    })();

    updateMissionText(); // hiển thị ban đầu
    newMission(1); // Khởi tạo nhiệm vụ đầu tiên

    // ------- Main animate -------
    function animate(){
      const dt = Math.min(0.05, clock.getDelta());

      let dirX=0, dirZ=0;
      if(keys.w) dirZ -= 1;
      if(keys.s) dirZ += 1;
      if(keys.a) dirX -= 1;
      if(keys.d) dirX += 1;

      const running = keys.shift;
      const baseSpeed = walkSpeed * (running ? runMultiplier : 1);
      const speed = baseSpeed * (inCar ? 2 : 1);
      const len = Math.hypot(dirX, dirZ);
      if(len>0){ dirX/=len; dirZ/=len; }

      if(len > 0){
        if(inCar){
          if(len > 0.001){
            // camera axes
            const camForward = new THREE.Vector3();
            camera.getWorldDirection(camForward);
            camForward.y = 0;
            camForward.normalize();
            const up = new THREE.Vector3(0,1,0);
            const camRight = new THREE.Vector3().crossVectors(camForward, up).normalize();

            // map input -> world direction
            const inputWorld = new THREE.Vector3();
            inputWorld.copy(camRight).multiplyScalar(dirX).add(camForward.clone().multiplyScalar(-dirZ));
            if(inputWorld.length() < 0.0001) return;
            inputWorld.normalize();

            // base desired (the "natural" angle from inputWorld)
            let desired = Math.atan2(inputWorld.x, -inputWorld.z);

            const baseForward = new THREE.Vector3(0,0,1);

            // --- diagonal handling: pick +90 or -90 so that forward aligns with inputWorld ---
            if(Math.abs(dirX) > 0.0001 && Math.abs(dirZ) > 0.0001){
              // propose two offsets
              const s = Math.sign(inputWorld.x || dirX);
              const offsets = [ s * Math.PI/2, -s * Math.PI/2 ];

              // choose offset that makes candidateForward dot inputWorld > 0
              let picked = 0;
              for(let i=0;i<offsets.length;i++){
                const cand = desired + offsets[i];
                const testQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, cand, 0));
                const candidateForward = baseForward.clone().applyQuaternion(testQuat).normalize();
                const d = candidateForward.dot(inputWorld);
                if(d > 0.01){
                  picked = i;
                  break;
                }
              }
              desired += offsets[picked];
            } else {
              const testQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, desired, 0));
              const candidateForward = baseForward.clone().applyQuaternion(testQuat).normalize();
              if(candidateForward.dot(inputWorld) < 0){
                desired += Math.PI;
              }
            }

            // slerp rotate and move by current forward
            const targetQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, desired, 0));
            car.quaternion.slerp(targetQuat, Math.min(1, 10 * dt));

            const forward = baseForward.clone().applyQuaternion(car.quaternion).normalize();
            const moveAmount = speed * (60 * dt) * len;
            car.position.add(forward.multiplyScalar(moveAmount));
          }
        }
        else {
          player.position.x += dirX * speed * (60*dt);
          player.position.z += dirZ * speed * (60*dt);
          player.rotation.y = Math.atan2(dirX, -dirZ);
        }
      }

      // Jump physics for player (only when not in car)
      if(!inCar){
        if(keys.space && onGround){ verticalVel = jumpSpeed; onGround=false; }
        if(!onGround){ 
          verticalVel += gravity*(60*dt); 
          player.position.y += verticalVel*(60*dt);
          if(player.position.y <= playerSize){ 
            player.position.y = playerSize; 
            verticalVel=0; 
            onGround=true; 
          }
        }
      } else {
        // nếu ở trong xe, fix y
        player.position.y = playerSize;
      }

      // Giới hạn trong map cho cả player và car
      const halfMap = 500 - 10;
      player.position.x = Math.max(-halfMap, Math.min(halfMap, player.position.x));
      player.position.z = Math.max(-halfMap, Math.min(halfMap, player.position.z));
      car.position.x = Math.max(-halfMap, Math.min(halfMap, car.position.x));
      car.position.z = Math.max(-halfMap, Math.min(halfMap, car.position.z));

      // Cập nhật cargo position nếu đang cầm
      if(hasCargo){
        if(inCar){
          cargoMesh.position.copy(car.position).add(new THREE.Vector3(0, 18, 0));
        } else {
          cargoMesh.position.copy(player.position).add(new THREE.Vector3(0, 12, 0));
        }
        cargoMesh.visible = true;
      } else {
        cargoMesh.visible = false;
      }

      // Camera follow target (player hoặc xe)
      const target = inCar ? car : player;
      const hDist = followDistance;
      const y = hDist * Math.tan(tiltRad);
      const camPos = new THREE.Vector3(target.position.x, target.position.y + y, target.position.z + hDist);

      camera.position.lerp(camPos, 1);
      camera.lookAt(target.position.x, target.position.y + 10, target.position.z);

      // Update mission UI
      updateMissionText();

      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }
    
    animate();
    document.body.addEventListener('click', ()=>{window.focus();});
  </script>
</body>
</html>