<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kh√¥ng gian 3D - G√≥c nh√¨n th·ª© nh·∫•t</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            max-width: 300px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        #gameUI {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 100;
            text-align: center;
            min-width: 200px;
        }
        
        #gameUI h3 {
            margin: 0 0 10px 0;
            color: #FFD700;
        }
        
        .coin-status {
            color: #00FF00;
            font-weight: bold;
        }
        
        .next-coin {
            color: #FFFF00;
            font-weight: bold;
        }
        
        .inventory {
            color: #FFA500;
            margin-top: 10px;
        }
        
        .weapon-info {
            color: #FF6B6B;
            margin-top: 10px;
            font-weight: bold;
        }
        
        #victory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #FFD700;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 24px;
            z-index: 200;
            display: none;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #FF0000;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 24px;
            z-index: 200;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="instructions">
            <h3>ƒêi·ªÅu khi·ªÉn:</h3>
            <p><strong>WASD</strong> - Di chuy·ªÉn</p>
            <p><strong>Mouse</strong> - Nh√¨n xung quanh</p>
            <p><strong>Space</strong> - Nh·∫£y</p>
            <p><strong>Shift</strong> - Ch·∫°y nhanh</p>
            <p><strong>Click tr√°i</strong> - N√©m v≈© kh√≠</p>
            <p><strong>E</strong> - Nh·∫∑t v≈© kh√≠/ƒë·ªìng xu</p>
            <p style="color: red; margin-top: 10px;">‚ö†Ô∏è C·∫®N TH·∫¨N: C√≥ zombie ƒëu·ªïi theo!</p>
            <p style="color: #FF6B6B; margin-top: 10px;">üó°Ô∏è N√©m v≈© kh√≠ v√†o zombie ƒë·ªÉ l√†m ch√∫ng cho√°ng!</p>
            <p style="color: #00FFFF; margin-top: 10px;">üí° V≈© kh√≠ s·∫Ω t·ª± ƒë·ªông nh·∫∑t khi b·∫°n ch·∫°m v√†o!</p>
        </div>
        <div id="crosshair"></div>
        <div id="gameUI">
            <h3>üéØ NHI·ªÜM V·ª§</h3>
            <div class="coin-status">ƒê·ªìng xu thu th·∫≠p: <span id="coinsCollected">0</span>/20</div>
            <div class="next-coin">T√¨m ƒë·ªìng xu s·ªë: <span id="nextCoin">1</span></div>
            <div class="inventory">ƒêang mang: <span id="inventory">0</span> ƒë·ªìng xu</div>
            <div class="weapon-info">V≈© kh√≠: <span id="weaponStatus">Kh√¥ng c√≥</span></div>
            <div style="margin-top: 10px; font-size: 12px; color: #CCC;">
                ƒêi ƒë·∫øn √¥ ƒë·ªè ƒë·ªÉ giao ƒë·ªìng xu
            </div>
            <div id="zombieWarning" style="color: red; font-weight: bold; margin-top: 10px; display: none;">
                ‚ö†Ô∏è ZOMBIE ƒêANG T·ªöI G·∫¶N!
            </div>
            <div id="zombieStunned" style="color: #00FFFF; font-weight: bold; margin-top: 10px; display: none;">
                üí´ ZOMBIE ƒêANG CHO√ÅNG!
            </div>
        </div>
        <div id="victory">
            <h2>üèÜ CHI·∫æN TH·∫ÆNG! üèÜ</h2>
            <p>B·∫°n ƒë√£ thu th·∫≠p ƒë·ªß 20 ƒë·ªìng xu!</p>
            <button onclick="location.reload()" style="padding: 10px 20px; font-size: 16px; margin-top: 20px;">Ch∆°i l·∫°i</button>
        </div>
        <div id="gameOver">
            <h2>‚ò†Ô∏è B·∫†N ƒê√É B·ªä ZOMBIE B·∫ÆT! ‚ò†Ô∏è</h2>
            <p>H√£y c·ªë g·∫Øng ch·∫°y nhanh h∆°n!</p>
            <button onclick="location.reload()" style="padding: 10px 20px; font-size: 16px; margin-top: 20px;">Ch∆°i l·∫°i</button>
        </div>
    </div>

    <script>
        // Kh·ªüi t·∫°o scene, camera, renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB); // M√†u tr·ªùi xanh
        document.getElementById('container').appendChild(renderer.domElement);

        // TƒÉng ƒë·ªô s√°ng
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1.0);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // T·∫°o m·∫∑t ƒë·∫•t v·ªõi hi·ªáu ·ª©ng l√°t s√†n
        const groundSize = 100;
        const tileSize = 5; // K√≠ch th∆∞·ªõc m·ªói √¥ s√†n
        
        // T·∫°o texture cho s√†n
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // V·∫Ω n·ªÅn xanh
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(0, 0, 512, 512);
        
        // V·∫Ω ƒë∆∞·ªùng k·∫ª √¥ vu√¥ng
        ctx.strokeStyle = '#388E3C';
        ctx.lineWidth = 2;
        
        for (let i = 0; i <= 512; i += 512 / (groundSize / tileSize)) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, 512);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(512, i);
            ctx.stroke();
        }
        
        const groundTexture = new THREE.CanvasTexture(canvas);
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(groundSize / tileSize, groundSize / tileSize);
        
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMaterial = new THREE.MeshLambertMaterial({ 
            map: groundTexture,
            transparent: true,
            opacity: 0.9
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // T·∫°o c√°c b·ª©c t∆∞·ªùng ·∫£o v·ªõi ƒë∆∞·ªùng k·∫ª
        const wallMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x888888,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        
        // T·∫°o 4 b·ª©c t∆∞·ªùng xung quanh
        const wallThickness = 1;
        const wallHeight = 10;
        
        // T∆∞·ªùng ph√≠a tr∆∞·ªõc (z = -50)
        const frontWall = new THREE.Mesh(
            new THREE.BoxGeometry(groundSize, wallHeight, wallThickness),
            wallMaterial
        );
        frontWall.position.set(0, wallHeight/2, -groundSize/2);
        scene.add(frontWall);
        
        // T∆∞·ªùng ph√≠a sau (z = 50)
        const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(groundSize, wallHeight, wallThickness),
            wallMaterial
        );
        backWall.position.set(0, wallHeight/2, groundSize/2);
        scene.add(backWall);
        
        // T∆∞·ªùng b√™n tr√°i (x = -50)
        const leftWall = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, wallHeight, groundSize),
            wallMaterial
        );
        leftWall.position.set(-groundSize/2, wallHeight/2, 0);
        scene.add(leftWall);
        
        // T∆∞·ªùng b√™n ph·∫£i (x = 50)
        const rightWall = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, wallHeight, groundSize),
            wallMaterial
        );
        rightWall.position.set(groundSize/2, wallHeight/2, 0);
        scene.add(rightWall);

        // T·∫°o √¥ ƒë·ªè ·ªü gi·ªØa (n∆°i giao ƒë·ªìng xu)
        const depositBoxGeometry = new THREE.BoxGeometry(4, 1, 4);
        const depositBoxMaterial = new THREE.MeshLambertMaterial({ 
            color: 0xFF0000,
            transparent: true,
            opacity: 0.8
        });
        const depositBox = new THREE.Mesh(depositBoxGeometry, depositBoxMaterial);
        depositBox.position.set(0, 0.5, 0);
        scene.add(depositBox);

        // T·∫°o bi·ªÉn b√°o cho √¥ ƒë·ªè
        const signGeometry = new THREE.PlaneGeometry(3, 1);
        const signCanvas = document.createElement('canvas');
        signCanvas.width = 256;
        signCanvas.height = 64;
        const signCtx = signCanvas.getContext('2d');
        signCtx.fillStyle = '#FFFFFF';
        signCtx.fillRect(0, 0, 256, 64);
        signCtx.fillStyle = '#FF0000';
        signCtx.font = '20px Arial';
        signCtx.textAlign = 'center';
        signCtx.fillText('N·ªòP ƒê·ªíNG XU', 128, 40);
        
        const signTexture = new THREE.CanvasTexture(signCanvas);
        const signMaterial = new THREE.MeshBasicMaterial({ map: signTexture });
        const sign = new THREE.Mesh(signGeometry, signMaterial);
        sign.position.set(0, 3, 0);
        scene.add(sign);

        // T·∫°o 20 ƒë·ªìng xu v·ªõi s·ªë th·ª© t·ª±
        const coins = [];
        const coinTextures = [];
        
        // T·∫°o texture cho t·ª´ng ƒë·ªìng xu
        for (let i = 1; i <= 20; i++) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // V·∫Ω ƒë·ªìng xu v√†ng
            ctx.beginPath();
            ctx.arc(32, 32, 30, 0, 2 * Math.PI);
            ctx.fillStyle = '#FFD700';
            ctx.fill();
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // V·∫Ω s·ªë
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(i.toString(), 32, 38);
            
            coinTextures.push(new THREE.CanvasTexture(canvas));
        }

        for (let i = 0; i < 20; i++) {
            const coinGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 32);
            const coinMaterial = new THREE.MeshLambertMaterial({ 
                map: coinTextures[i],
                color: 0xFFD700
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);

            // Xoay ƒë·ªìng xu ƒë·ª©ng d·ªçc
            coin.rotation.z = Math.PI / 2;

            // ƒê·∫∑t ƒë·ªìng xu ·ªü v·ªã tr√≠ ng·∫´u nhi√™n (tr√°nh √¥ ƒë·ªè ·ªü gi·ªØa)
            let x, z;
            do {
                x = (Math.random() - 0.5) * 80;
                z = (Math.random() - 0.5) * 80;
            } while (Math.abs(x) < 8 && Math.abs(z) < 8);

            coin.position.set(x, 1, z);
            coin.userData = { number: i + 1, collected: false, type: 'coin' };

            scene.add(coin);
            coins.push(coin);
        }

        // T·∫°o zombie
        function createZombie() {
            const zombieGroup = new THREE.Group();
            
            // Th√¢n zombie
            const bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            zombieGroup.add(body);
            
            // ƒê·∫ßu zombie
            const headGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.2;
            zombieGroup.add(head);
            
            // M·∫Øt zombie (m√†u ƒë·ªè)
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 2.2, 0.5);
            zombieGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 2.2, 0.5);
            zombieGroup.add(rightEye);
            
            // ƒê·∫∑t v·ªã tr√≠ ng·∫´u nhi√™n cho zombie
            let x, z;
            do {
                x = (Math.random() - 0.5) * 70;
                z = (Math.random() - 0.5) * 70;
            } while (Math.abs(x) < 10 && Math.abs(z) < 10);
            
            zombieGroup.position.set(x, 0, z);
            zombieGroup.userData = { 
                speed: 0.05, 
                stunned: false,
                stunTimer: 0
            };
            
            return zombieGroup;
        }

        const zombie = createZombie();
        scene.add(zombie);

        // T·∫°o v≈© kh√≠
        function createWeapon(type, position) {
            let geometry, material, scale;
            
            switch(type) {
                case 'knife':
                    geometry = new THREE.CylinderGeometry(0.1, 0.3, 1, 8);
                    material = new THREE.MeshLambertMaterial({ color: 0x888888 });
                    scale = 1;
                    break;
                case 'axe':
                    geometry = new THREE.BoxGeometry(0.2, 1, 0.5);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    scale = 1;
                    break;
                case 'hammer':
                    geometry = new THREE.BoxGeometry(0.4, 0.4, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0xCD7F32 });
                    scale = 1;
                    break;
                case 'spear':
                    geometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8);
                    material = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
                    scale = 1;
                    break;
                case 'shuriken':
                    geometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 6);
                    material = new THREE.MeshLambertMaterial({ color: 0x0000FF });
                    scale = 0.5;
                    break;
                case 'sword':
                    geometry = new THREE.BoxGeometry(0.1, 1.2, 0.3);
                    material = new THREE.MeshLambertMaterial({ color: 0xE0E0E0 });
                    scale = 1;
                    break;
                case 'dagger':
                    geometry = new THREE.CylinderGeometry(0.05, 0.1, 0.8, 8);
                    material = new THREE.MeshLambertMaterial({ color: 0xA0A0A0 });
                    scale = 1;
                    break;
                case 'mace':
                    geometry = new THREE.SphereGeometry(0.4, 16, 16);
                    material = new THREE.MeshLambertMaterial({ color: 0x606060 });
                    scale = 1;
                    break;
                case 'bow':
                    geometry = new THREE.TorusGeometry(0.5, 0.1, 8, 32, Math.PI);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    scale = 1;
                    break;
                case 'staff':
                    geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.8, 8);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    scale = 1;
                    break;
            }
            
            const weapon = new THREE.Mesh(geometry, material);
            weapon.position.copy(position);
            weapon.scale.set(scale, scale, scale);
            weapon.userData = { 
                type: type, 
                collected: false,
                isThrown: false,
                throwDirection: new THREE.Vector3(),
                throwSpeed: 0,
                throwTime: 0
            };
            
            return weapon;
        }

        // T·∫°o 10 v≈© kh√≠ ·ªü c√°c v·ªã tr√≠ ng·∫´u nhi√™n (5 v≈© kh√≠ ban ƒë·∫ßu + 5 v≈© kh√≠ m·ªõi)
        const weapons = [];
        const weaponTypes = ['knife', 'axe', 'hammer', 'spear', 'shuriken', 'sword', 'dagger', 'mace', 'bow', 'staff'];
        
        for (let i = 0; i < 10; i++) {
            let x, z;
            do {
                x = (Math.random() - 0.5) * 80;
                z = (Math.random() - 0.5) * 80;
            } while (Math.abs(x) < 8 && Math.abs(z) < 8);
            
            const weapon = createWeapon(weaponTypes[i], new THREE.Vector3(x, 1, z));
            scene.add(weapon);
            weapons.push(weapon);
        }

        // Game state
        const gameState = {
            coinsCollected: 0,
            nextCoinToFind: 1,
            inventory: 0,
            currentWeapon: null,
            gameWon: false,
            gameOver: false,
            baseSpeed: 0.15,
            sprintSpeed: 0.3
        };

        // C·∫≠p nh·∫≠t UI
        function updateUI() {
            document.getElementById('coinsCollected').textContent = gameState.coinsCollected;
            document.getElementById('nextCoin').textContent = gameState.nextCoinToFind;
            document.getElementById('inventory').textContent = gameState.inventory;
            
            if (gameState.currentWeapon) {
                document.getElementById('weaponStatus').textContent = gameState.currentWeapon.userData.type.toUpperCase();
            } else {
                document.getElementById('weaponStatus').textContent = "Kh√¥ng c√≥";
            }
            
            if (gameState.coinsCollected === 20) {
                document.getElementById('victory').style.display = 'block';
                gameState.gameWon = true;
            }
        }

        // Ki·ªÉm tra va ch·∫°m v·ªõi ƒë·ªìng xu
        function checkCoinCollision() {
            const playerPosition = camera.position;
            
            coins.forEach(coin => {
                if (!coin.userData.collected && coin.userData.number === gameState.nextCoinToFind) {
                    const distance = playerPosition.distanceTo(coin.position);
                    if (distance < 2) {
                        // Thu th·∫≠p ƒë·ªìng xu
                        coin.userData.collected = true;
                        coin.visible = false;
                        gameState.inventory++;
                        gameState.nextCoinToFind++;
                        updateUI();
                        
                        console.log(`ƒê√£ thu th·∫≠p ƒë·ªìng xu s·ªë ${coin.userData.number}!`);
                    }
                }
            });
        }

        // Ki·ªÉm tra va ch·∫°m v·ªõi v≈© kh√≠ (t·ª± ƒë·ªông nh·∫∑t)
        function checkWeaponCollision() {
            const playerPosition = camera.position;
            
            weapons.forEach(weapon => {
                if (!weapon.userData.collected && !weapon.userData.isThrown) {
                    const distance = playerPosition.distanceTo(weapon.position);
                    if (distance < 2) {
                        // T·ª± ƒë·ªông nh·∫∑t v≈© kh√≠ n·∫øu kh√¥ng c√≥ v≈© kh√≠ n√†o
                        if (!gameState.currentWeapon) {
                            weapon.userData.collected = true;
                            weapon.visible = false;
                            gameState.currentWeapon = weapon;
                            updateUI();
                            
                            console.log(`ƒê√£ nh·∫∑t v≈© kh√≠: ${weapon.userData.type}`);
                        }
                    }
                }
            });
        }

        // Ki·ªÉm tra va ch·∫°m v·ªõi √¥ ƒë·ªè (n·ªôp ƒë·ªìng xu)
        function checkDepositBoxCollision() {
            const playerPosition = camera.position;
            const depositPosition = depositBox.position;
            const distance = playerPosition.distanceTo(depositPosition);
            
            if (distance < 3 && gameState.inventory > 0) {
                // N·ªôp t·∫•t c·∫£ ƒë·ªìng xu trong t√∫i
                gameState.coinsCollected += gameState.inventory;
                gameState.inventory = 0;
                updateUI();
                console.log(`ƒê√£ n·ªôp ƒë·ªìng xu! T·ªïng c·ªông: ${gameState.coinsCollected}/20`);
            }
        }

        // Ki·ªÉm tra va ch·∫°m v·ªõi zombie
        function checkZombieCollision() {
            const playerPosition = camera.position;
            const zombiePosition = zombie.position;
            const distance = playerPosition.distanceTo(zombiePosition);
            
            // Hi·ªÉn th·ªã c·∫£nh b√°o n·∫øu zombie g·∫ßn
            if (distance < 15) {
                document.getElementById('zombieWarning').style.display = 'block';
            } else {
                document.getElementById('zombieWarning').style.display = 'none';
            }
            
            // Hi·ªÉn th·ªã tr·∫°ng th√°i cho√°ng
            if (zombie.userData.stunned) {
                document.getElementById('zombieStunned').style.display = 'block';
            } else {
                document.getElementById('zombieStunned').style.display = 'none';
            }
            
            // K·∫øt th√∫c game n·∫øu zombie b·∫Øt ƒë∆∞·ª£c ng∆∞·ªùi ch∆°i
            if (distance < 2.5 && !zombie.userData.stunned) {
                document.getElementById('gameOver').style.display = 'block';
                gameState.gameOver = true;
            }
            
            return distance;
        }

        // N√©m v≈© kh√≠
        function throwWeapon() {
            if (!gameState.currentWeapon) return;
            
            const weapon = gameState.currentWeapon;
            weapon.visible = true;
            weapon.position.copy(camera.position);
            
            // X√°c ƒë·ªãnh h∆∞·ªõng n√©m (d·ª±a v√†o h∆∞·ªõng nh√¨n c·ªßa camera)
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            weapon.userData.isThrown = true;
            weapon.userData.throwDirection = direction.normalize();
            weapon.userData.throwSpeed = 0.5;
            weapon.userData.throwTime = 0;
            
            gameState.currentWeapon = null;
            updateUI();
        }

        // C·∫≠p nh·∫≠t v≈© kh√≠ ƒëang bay
        function updateThrownWeapons() {
            weapons.forEach(weapon => {
                if (weapon.userData.isThrown) {
                    // C·∫≠p nh·∫≠t v·ªã tr√≠ v≈© kh√≠
                    weapon.position.addScaledVector(weapon.userData.throwDirection, weapon.userData.throwSpeed);
                    weapon.userData.throwTime++;
                    
                    // Xoay v≈© kh√≠ khi bay
                    weapon.rotation.x += 0.2;
                    weapon.rotation.y += 0.1;
                    
                    // Ki·ªÉm tra n·∫øu v≈© kh√≠ ch·∫°m zombie
                    const distanceToZombie = weapon.position.distanceTo(zombie.position);
                    if (distanceToZombie < 2) {
                        // L√†m zombie cho√°ng
                        zombie.userData.stunned = true;
                        zombie.userData.stunTimer = 300; // 5 gi√¢y (60fps * 5)
                        
                        // ·∫®n v≈© kh√≠
                        weapon.userData.isThrown = false;
                        weapon.visible = false;
                        
                        console.log("Zombie ƒë√£ b·ªã cho√°ng!");
                    }
                    
                    // Ki·ªÉm tra n·∫øu v≈© kh√≠ bay qu√° xa
                    if (weapon.userData.throwTime > 100) {
                        weapon.userData.isThrown = false;
                        weapon.userData.throwSpeed = 0;
                    }
                    
                    // Ki·ªÉm tra n·∫øu v≈© kh√≠ ch·∫°m ƒë·∫•t
                    if (weapon.position.y <= 0.5) {
                        weapon.userData.isThrown = false;
                        weapon.userData.throwSpeed = 0;
                    }
                }
            });
        }

        // V·ªã tr√≠ v√† ƒëi·ªÅu khi·ªÉn ng∆∞·ªùi ch∆°i
        const playerHeight = 1.8;
        camera.position.set(0, playerHeight, 0);

        const movement = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            sprint: false
        };

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let isOnGround = true;
        let jumpVelocity = 0;

        // ƒêi·ªÅu khi·ªÉn b√†n ph√≠m
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': movement.forward = true; break;
                case 'KeyS': movement.backward = true; break;
                case 'KeyA': movement.left = true; break;
                case 'KeyD': movement.right = true; break;
                case 'Space': 
                    event.preventDefault();
                    if (isOnGround) {
                        movement.jump = true;
                        jumpVelocity = 0.3;
                        isOnGround = false;
                    }
                    break;
                case 'ShiftLeft': movement.sprint = true; break;
                case 'KeyE': 
                    // V·∫´n gi·ªØ ph√≠m E ƒë·ªÉ nh·∫∑t v≈© kh√≠ n·∫øu c·∫ßn
                    checkWeaponCollision(); 
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': movement.forward = false; break;
                case 'KeyS': movement.backward = false; break;
                case 'KeyA': movement.left = false; break;
                case 'KeyD': movement.right = false; break;
                case 'ShiftLeft': movement.sprint = false; break;
            }
        });

        // ƒêi·ªÅu khi·ªÉn chu·ªôt
        let mouseX = 0;
        let mouseY = 0;
        let isLocked = false;

        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;

        document.addEventListener('click', (event) => {
            if (event.button === 0) { // Click chu·ªôt tr√°i
                if (isLocked) {
                    throwWeapon();
                } else {
                    document.body.requestPointerLock();
                }
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isLocked = document.pointerLockElement === document.body;
        });

        document.addEventListener('mousemove', (event) => {
            if (!isLocked) return;

            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
            camera.quaternion.setFromEuler(euler);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (gameState.gameWon || gameState.gameOver) {
                renderer.render(scene, camera);
                return;
            }

            // T√≠nh t·ªëc ƒë·ªô d·ª±a tr√™n s·ªë ƒë·ªìng xu ƒëang mang (gi·∫£m 5% m·ªói ƒë·ªìng)
            const speedMultiplier = 1 - (gameState.inventory * 0.05);
            const currentBaseSpeed = Math.max(0.05, gameState.baseSpeed * speedMultiplier);
            const currentSprintSpeed = Math.max(0.1, gameState.sprintSpeed * speedMultiplier);
            
            const speed = movement.sprint ? currentSprintSpeed : currentBaseSpeed;
            
            direction.set(0, 0, 0);

            if (movement.forward) direction.z -= 1;
            if (movement.backward) direction.z += 1;
            if (movement.left) direction.x -= 1;
            if (movement.right) direction.x += 1;

            direction.normalize();
            direction.multiplyScalar(speed);

            // √Åp d·ª•ng rotation cho direction
            const rotatedDirection = direction.clone();
            rotatedDirection.applyQuaternion(camera.quaternion);
            rotatedDirection.y = 0; // Kh√¥ng di chuy·ªÉn theo tr·ª•c Y

            // C·∫≠p nh·∫≠t v·ªã tr√≠
            camera.position.add(rotatedDirection);

            // X·ª≠ l√Ω nh·∫£y v√† tr·ªçng l·ª±c
            if (movement.jump || !isOnGround) {
                camera.position.y += jumpVelocity;
                jumpVelocity -= 0.015; // Tr·ªçng l·ª±c

                if (camera.position.y <= playerHeight) {
                    camera.position.y = playerHeight;
                    isOnGround = true;
                    jumpVelocity = 0;
                    movement.jump = false;
                }
            }

            // Gi·ªõi h·∫°n v√πng di chuy·ªÉn
            camera.position.x = Math.max(-45, Math.min(45, camera.position.x));
            camera.position.z = Math.max(-45, Math.min(45, camera.position.z));

            // C·∫≠p nh·∫≠t animation ƒë·ªìng xu
            coins.forEach(coin => {
                if (!coin.userData.collected) {
                    coin.rotation.y += 0.05; // quay d·ª±ng ƒë·ª©ng
                    coin.position.y = 1 + Math.sin(Date.now() * 0.003 + coin.userData.number) * 0.2;
                }
            });

            // Hi·ªáu ·ª©ng cho √¥ ƒë·ªè
            depositBox.rotation.y += 0.01;
            const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1;
            depositBox.scale.set(pulse, 1, pulse);

            // C·∫≠p nh·∫≠t tr·∫°ng th√°i cho√°ng c·ªßa zombie
            if (zombie.userData.stunned) {
                zombie.userData.stunTimer--;
                if (zombie.userData.stunTimer <= 0) {
                    zombie.userData.stunned = false;
                }
                
                // Hi·ªáu ·ª©ng cho√°ng (l·∫Øc l∆∞)
                zombie.rotation.z = Math.sin(Date.now() * 0.01) * 0.2;
            } else {
                zombie.rotation.z = 0;
                
                // Di chuy·ªÉn zombie theo ng∆∞·ªùi ch∆°i
                const playerPos = camera.position.clone();
                const zombiePos = zombie.position.clone();
                
                // T√≠nh h∆∞·ªõng di chuy·ªÉn c·ªßa zombie
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(playerPos, zombiePos)
                    .normalize();
                
                // T·ªëc ƒë·ªô zombie b·∫±ng 1/3 t·ªëc ƒë·ªô ch·∫°y c·ªßa ng∆∞·ªùi ch∆°i
                const zombieSpeed = speed / 3;
                directionToPlayer.multiplyScalar(zombieSpeed);
                
                // C·∫≠p nh·∫≠t v·ªã tr√≠ zombie
                zombie.position.add(directionToPlayer);
                
                // Xoay zombie ƒë·ªÉ h∆∞·ªõng v·ªÅ ph√≠a ng∆∞·ªùi ch∆°i
                zombie.lookAt(playerPos);
            }
            
            // Gi·ªõi h·∫°n v√πng di chuy·ªÉn c·ªßa zombie
            zombie.position.x = Math.max(-45, Math.min(45, zombie.position.x));
            zombie.position.z = Math.max(-45, Math.min(45, zombie.position.z));

            // C·∫≠p nh·∫≠t v≈© kh√≠ ƒëang bay
            updateThrownWeapons();

            // Ki·ªÉm tra va ch·∫°m
            checkCoinCollision();
            checkWeaponCollision(); // Ki·ªÉm tra va ch·∫°m v≈© kh√≠ t·ª± ƒë·ªông
            checkDepositBoxCollision();
            checkZombieCollision();

            renderer.render(scene, camera);
        }

        // Kh·ªüi t·∫°o UI
        updateUI();

               // X·ª≠ l√Ω resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // B·∫Øt ƒë·∫ßu animation
        animate();
    </script>
</body>
</html>