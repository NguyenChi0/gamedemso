<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Space Coin Hunter - Expanded Universe</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
      cursor: none;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 20px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    #instructions {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-size: 14px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    #phase-indicator {
      position: absolute;
      top: 120px;
      left: 10px;
      color: #ffff00;
      font-size: 18px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    #control-mode {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      font-size: 14px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }
    .custom-cursor {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid #00ffff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 0 10px #00ffff;
    }
    .cursor-dot {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #00ffff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1001;
    }
    #result-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 2000;
      font-size: 18px;
      max-width: 80%;
      display: none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>ƒê·ªìng xu: <span id="score">0</span>/30</div>
    <div>NƒÉng l∆∞·ª£ng: <span id="energy">100</span>%</div>
    <div>Th·ªùi gian: <span id="game-time">00:00</span></div>
  </div>
  <div id="phase-indicator">
    <div id="phase-text">Giai ƒëo·∫°n 1: Thu th·∫≠p xu 1-10</div>
  </div>
  <div id="instructions">
    <div>ƒêi·ªÅu khi·ªÉn: ‚Üê ‚Üí ‚Üë ‚Üì ho·∫∑c di chu·ªôt</div>
    <div>Space: T·∫•n c√¥ng (Gƒê3)</div>
    <div>Shift: TƒÉng t·ªëc (t·ªën nƒÉng l∆∞·ª£ng)</div>
    <div>C: Chuy·ªÉn ch·∫ø ƒë·ªô ƒëi·ªÅu khi·ªÉn</div>
    <div>T√¨m 30 ƒë·ªìng xu trong v≈© tr·ª•!</div>
  </div>
  <div id="control-mode">
    Ch·∫ø ƒë·ªô: <span id="mode-display">B√†n ph√≠m</span>
  </div>
  <div id="result-message"></div>

  <div class="custom-cursor" id="custom-cursor"></div>
  <div class="cursor-dot" id="cursor-dot"></div>

  <script>
  let player;
  let coins = [];
  let stars = [];
  let meteors = [];
  let blackholes = [];
  let lasers = [];
  let worldWidth = 1500;
  let worldHeight = 1500;
  let score = 0;
  let meteorCount = 0;
  let gameComplete = false;
  let expectedCoinNumber = 1;
  let gameOver = false;
  let currentPhase = 1;
  let cameraZoom = 1;
  let targetZoom = 1;
  let astronautImg;
  let laserSound;
  let coinSound;
  let energy = 100;
  let lastEnergyUpdate = 0;
  let lastBlackholeSpawn = 0;
  let blackholeCount = 0;
  let startTime;
  let finishTime;
  let gameDuration = 0;
  let isBoosting = false;
  let boostMultiplier = 1;
  let controlMode = 'keyboard'; // 'keyboard' or 'mouse'
  let mouseControlActive = false;
  let mouseX = 0;
  let mouseY = 0;
  let expandedWorld = false;
  let finalPhase = false;
  let scoreSent = false;

  function preload() {
    astronautImg = loadImage('tenlua.png');
    // Th√™m √¢m thanh n·∫øu c√≥
    // laserSound = loadSound('laser.wav');
    // coinSound = loadSound('coin.wav');
  }

  function formatTime(ms) {
    let seconds = floor(ms / 1000) % 60;
    let minutes = floor(ms / 60000);
    return nf(minutes, 2) + ":" + nf(seconds, 2);
  }

  function setup() {
    createCanvas(windowWidth, windowHeight);
    resetGame();
    
    // ·∫®n con tr·ªè chu·ªôt m·∫∑c ƒë·ªãnh
    document.body.style.cursor = 'none';
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ con tr·ªè t√πy ch·ªânh
    document.addEventListener('mousemove', function(e) {
      mouseX = e.clientX;
      mouseY = e.clientY;
      
      const cursor = document.getElementById('custom-cursor');
      const dot = document.getElementById('cursor-dot');
      
      if (cursor && dot) {
        cursor.style.left = e.clientX + 'px';
        cursor.style.top = e.clientY + 'px';
        dot.style.left = e.clientX + 'px';
        dot.style.top = e.clientY + 'px';
      }
    });
  }

  function resetGame() {
    score = 0;
    meteorCount = 0;
    gameComplete = false;
    expectedCoinNumber = 1;
    gameOver = false;
    currentPhase = 1;
    cameraZoom = 1;
    targetZoom = 1;
    expandedWorld = false;
    finalPhase = false;
    worldWidth = 1500;
    worldHeight = 1500;
    energy = 100;
    blackholeCount = 0;
    startTime = millis();
    finishTime = 0;
    gameDuration = 0;
    controlMode = 'keyboard';
    scoreSent = false;

    player = {
      x: worldWidth / 2,
      y: worldHeight / 2,
      size: 120,
      vx: 0,
      vy: 0,
      thrust: 0.2,
      drag: 0.95,
      trail: [],

      lastShot: 0,
      invincible: false,
      rotation: 0,
      targetRotation: 0
    };

    coins = [];
    // T·∫°o 10 ƒë·ªìng xu ƒë·∫ßu ti√™n
    for (let i = 1; i <= 10; i++) {
      coins.push({
        x: random(100, worldWidth - 100),
        y: random(100, worldHeight - 100),
        size: 60,
        collected: false,
        number: i,
        glow: 0,
        rotation: 0,
        phase: 1,
        shouldRotate: ![6, 9].includes(i) // Ch·ªâ quay n·∫øu kh√¥ng ph·∫£i s·ªë 6 ho·∫∑c 9
      });
    }

    stars = [];
    generateStars();

    meteors = [];
    blackholes = [];
    lasers = [];
  }

  function generateStars() {
    stars = [];
    let starCount = expandedWorld ? (finalPhase ? 500 : 300) : 100;
    for (let i = 0; i < starCount; i++) {
      stars.push({
        x: random(worldWidth),
        y: random(worldHeight),
        size: random(1, 4),
        brightness: random(100, 255),
        twinkle: random(0.01, 0.05)
      });
    }
  }

  function expandUniverse() {
    // M·ªü r·ªông th·∫ø gi·ªõi
    worldWidth = 3000;
    worldHeight = 3000;
    expandedWorld = true;
    
    // Thu nh·ªè camera ƒë·ªÉ nh√¨n r·ªông h∆°n
    targetZoom = 0.5;
    
    // T·∫°o th√™m sao
    generateStars();
    
    // T·∫°o 10 ƒë·ªìng xu ti·∫øp theo (11-20)
    for (let i = 11; i <= 20; i++) {
      coins.push({
        x: random(100, worldWidth - 100),
        y: random(100, worldHeight - 100),
        size: 100,
        collected: false,
        number: i,
        glow: 0,
        rotation: 0,
        phase: 2,
        shouldRotate: ![6, 9, 16, 19].includes(i) // Ch·ªâ quay n·∫øu kh√¥ng ph·∫£i s·ªë 6,9,16,19
      });
    }
    
    currentPhase = 2;
  }

  function activateFinalPhase() {
    // K√≠ch ho·∫°t giai ƒëo·∫°n cu·ªëi
    worldWidth = 5000;
    worldHeight = 5000;
    finalPhase = true;
    targetZoom = 0.3;
    
    // T·∫°o th√™m sao
    generateStars();
    
    // T·∫°o 10 ƒë·ªìng xu cu·ªëi c√πng (21-30)
    for (let i = 21; i <= 30; i++) {
      coins.push({
        x: random(100, worldWidth - 100),
        y: random(100, worldHeight - 100),
        size: 120,
        collected: false,
        number: i,
        glow: 0,
        rotation: 0,
        phase: 3,
        shouldRotate: ![6, 9, 16, 19, 26, 29].includes(i), // Ch·ªâ quay n·∫øu kh√¥ng ph·∫£i s·ªë 6,9,16,19,26,29
        isSpecial: [21, 23, 28, 30].includes(i) // ƒê√°nh d·∫•u c√°c ƒë·ªìng xu ƒë·∫∑c bi·ªát
      });
    }
    
    currentPhase = 3;
    player.invincible = false;
    player.size = 100; // Nh√¢n v·∫≠t nh·ªè h∆°n ƒë·ªÉ n√© d·ªÖ h∆°n
    
    // T·∫°o l·ªó ƒëen ƒë·∫ßu ti√™n
    createBlackhole();
    lastBlackholeSpawn = millis();
  }

  function createBlackhole() {
    // T·∫°o l·ªó ƒëen ·ªü v·ªã tr√≠ ng·∫´u nhi√™n xa ng∆∞·ªùi ch∆°i
    let x, y;
    let safeDistance = 800;
    
    do {
      x = random(100, worldWidth - 100);
      y = random(100, worldHeight - 100);
    } while (dist(x, y, player.x, player.y) < safeDistance);
    
    blackholes.push({
      x: x,
      y: y,
      size: 150,
      pullRadius: 400,
      rotation: 0,
      life: 10000, // 10 gi√¢y
      spawnTime: millis()
    });
    
    blackholeCount++;
  }

  function draw() {
    // Gradient background
    for (let i = 0; i <= height; i++) {
      let inter = map(i, 0, height, 0, 1);
      let c = lerpColor(color(10, 10, 30), color(5, 5, 15), inter);
      stroke(c);
      line(0, i, width, i);
    }

    // Smooth camera zoom transition
    cameraZoom = lerp(cameraZoom, targetZoom, 0.02);

    push();
    // Apply camera zoom
    scale(cameraZoom);
    translate((width/cameraZoom) / 2 - player.x, (height/cameraZoom) / 2 - player.y);

    if (!expandedWorld) {
      drawWorldBorder();
    }
    drawStars();
    updateMeteors();
    drawMeteors();
    updateBlackholes();
    drawBlackholes();
    
    drawCoins();
    drawPlayer();
    pop();

    if (!gameOver && !gameComplete) {
      updatePlayer();
      if (random() < 0.003) {
        createMeteor();
      }
      
      // T·∫°o l·ªó ƒëen m·ªõi m·ªói 15 gi√¢y trong giai ƒëo·∫°n 3
      if (currentPhase === 3 && millis() - lastBlackholeSpawn > 15000 && blackholes.length < 3) {
        createBlackhole();
        lastBlackholeSpawn = millis();
      }
      
      // H·ªìi ph·ª•c nƒÉng l∆∞·ª£ng
      if (millis() - lastEnergyUpdate > 1000 && energy < 100) {
        energy += 5;
        energy = constrain(energy, 0, 100);
        lastEnergyUpdate = millis();
      }
    }

    updateUI();

    // Ki·ªÉm tra ho√†n th√†nh giai ƒëo·∫°n 1
    if (score >= 10 && currentPhase === 1) {
      expandUniverse();
      showPhaseMessage("V≈© tr·ª• ƒë√£ m·ªü r·ªông! T√¨m 10 ƒë·ªìng xu ti·∫øp theo (11-20)");
    }
    
    // Ki·ªÉm tra ho√†n th√†nh giai ƒëo·∫°n 2
    if (score >= 20 && currentPhase === 2) {
      activateFinalPhase();
      showPhaseMessage("V≈© tr·ª• ƒë√£ m·ªü r·ªông t·ªëi ƒëa! T√¨m 10 ƒë·ªìng xu cu·ªëi c√πng (21-30)\nC·∫©n th·∫≠n v·ªõi l·ªó ƒëen! D√πng SPACE ƒë·ªÉ b·∫Øn");
    }

    // Trong ph·∫ßn ki·ªÉm tra ho√†n th√†nh game
    if (score >= 30 && !gameComplete) {
      gameComplete = true;
      finishTime = millis();
      gameDuration = finishTime - startTime;
      targetZoom = 1;
      showPhaseMessage(`Ho√†n th√†nh trong ${formatTime(gameDuration)}! Nh·∫•n R ƒë·ªÉ ch∆°i l·∫°i`);
      sendScoreToServer();
    }

    // Hi·ªÉn th·ªã tr·∫°ng th√°i th·∫Øng/thua
    if (gameComplete || gameOver) {
      push();
      scale(1/cameraZoom); // ƒê·∫£m b·∫£o text kh√¥ng b·ªã zoom
      fill(gameOver ? 'red' : 'lime');
      textSize(36);
      textAlign(CENTER, CENTER);
      text(gameOver ? 'B·∫°n ƒë√£ ch·ªçn sai ƒë·ªìng xu ho·∫∑c b·ªã h√∫t v√†o l·ªó ƒëen!\nNh·∫•n R ƒë·ªÉ ch∆°i l·∫°i' : 
           'Ch√∫c m·ª´ng! B·∫°n ƒë√£ thu th·∫≠p ƒë·ªß 30 ƒë·ªìng xu!\nNh·∫•n R ƒë·ªÉ ch∆°i l·∫°i', 
           (width/cameraZoom) / 2, (height/cameraZoom) / 2);
      pop();
      
      // G·ª≠i ƒëi·ªÉm khi game over (n·∫øu ch∆∞a g·ª≠i)
      if (gameOver && !scoreSent) {
        sendScoreToServer();
      }
    }
  }

  function drawCoins() {
    for (let coin of coins) {
      if (!coin.collected) {
        coin.glow += 0.1;
        // Ch·ªâ quay n·∫øu shouldRotate l√† true
        if (coin.shouldRotate) {
          coin.rotation += 0.05;
        }

        push();
        translate(coin.x, coin.y);
        rotate(coin.rotation);
        
        // M√†u kh√°c nhau cho t·ª´ng phase
        let coinColor;
        if (coin.phase === 1) {
          coinColor = [255, 215, 0]; // V√†ng cho phase 1
        } else if (coin.phase === 2) {
          coinColor = [255, 100, 255]; // T√≠m cho phase 2
        } else {
          // Phase 3: m√†u ƒë·∫∑c bi·ªát cho m·ªôt s·ªë ƒë·ªìng xu
          if (coin.isSpecial) {
            // ƒê·ªìng xu ƒë·∫∑c bi·ªát c√≥ m√†u xanh ng·ªçc
            coinColor = [100, 255, 255];
          } else {
            // ƒê·ªìng xu th∆∞·ªùng phase 3 m√†u ƒë·ªè
            coinColor = [255, 100, 100];
          }
        }
        
        fill(coinColor[0], coinColor[1], coinColor[2], 50 + sin(coin.glow) * 50);
        noStroke();
        ellipse(0, 0, coin.size * 2);
        fill(coinColor[0], coinColor[1], coinColor[2]);
        stroke(coinColor[0] * 0.7, coinColor[1] * 0.7, coinColor[2] * 0.7);
        strokeWeight(2);
        ellipse(0, 0, coin.size);
        fill(0);
        textAlign(CENTER, CENTER);
        textSize(30);
        textStyle(BOLD);
        text(coin.number, 0, 0);
        pop();

        if (!gameOver && dist(player.x, player.y, coin.x, coin.y) < 35) {
          if (coin.number === expectedCoinNumber) {
            coin.collected = true;
            score++;
            expectedCoinNumber++;
            for (let i = 0; i < 10; i++) {
              createSparkle(coin.x, coin.y);
            }
            // if (coinSound) coinSound.play();
            
            // ƒê·ªìng xu ƒë·∫∑c bi·ªát h·ªìi nƒÉng l∆∞·ª£ng
            if (coin.isSpecial) {
              energy = min(100, energy + 30);
            }
          } else {
            gameOver = true;
            return;
          }
        }
      }
    }
  }

  function showPhaseMessage(message) {
    // Hi·ªÉn th·ªã th√¥ng b√°o chuy·ªÉn phase
    setTimeout(() => {
      push();
      scale(1/cameraZoom); // ƒê·∫£m b·∫£o text kh√¥ng b·ªã zoom
      fill(255, 255, 0);
      textSize(24);
      textAlign(CENTER, CENTER);
      text(message, (width/cameraZoom) / 2, (height/cameraZoom) / 2 - 100);
      pop();
    }, 100);
  }

  function keyPressed() {
    if ((gameComplete || gameOver) && key === 'r') {
      resetGame();
    }
    
    // Chuy·ªÉn ch·∫ø ƒë·ªô ƒëi·ªÅu khi·ªÉn
    if (key === 'c' || key === 'C') {
      toggleControlMode();
    }
  }

  function toggleControlMode() {
    if (controlMode === 'keyboard') {
      controlMode = 'mouse';
      document.getElementById('mode-display').textContent = 'Chu·ªôt';
    } else {
      controlMode = 'keyboard';
      document.getElementById('mode-display').textContent = 'B√†n ph√≠m';
    }
  }

  function updateBlackholes() {
    for (let i = blackholes.length - 1; i >= 0; i--) {
      let bh = blackholes[i];
      bh.rotation += 0.01;
      bh.life -= (millis() - bh.spawnTime) > bh.life ? 100 : 0; // Gi·∫£m life n·∫øu qu√° th·ªùi gian
      
      // Hi·ªáu ·ª©ng h√∫t
      if (!player.invincible) {
        let distance = dist(player.x, player.y, bh.x, bh.y);
        if (distance < bh.pullRadius) {
          // T√≠nh l·ª±c h√∫t (t·ªâ l·ªá ngh·ªãch v·ªõi b√¨nh ph∆∞∆°ng kho·∫£ng c√°ch)
          let pullForce = 1000 / (distance * distance);
          let angle = atan2(bh.y - player.y, bh.x - player.x);
          
          player.vx += cos(angle) * pullForce;
          player.vy += sin(angle) * pullForce;
          
          // Ki·ªÉm tra n·∫øu b·ªã h√∫t v√†o l·ªó ƒëen
          if (distance < bh.size/2) {
            gameOver = true;
          }
        }
      }
      
      // X√≥a l·ªó ƒëen n·∫øu h·∫øt ƒë·ªùi
      if (bh.life <= 0) {
        blackholes.splice(i, 1);
      }
    }
  }

  function drawBlackholes() {
    for (let bh of blackholes) {
      push();
      translate(bh.x, bh.y);
      rotate(bh.rotation);
      
      // V·∫Ω l·ªó ƒëen
      fill(0);
      stroke(100, 0, 150);
      strokeWeight(3);
      ellipse(0, 0, bh.size);
      
      // V·∫Ω vi·ªÅn xo√°y
      noFill();
      stroke(150, 0, 200, 150);
      strokeWeight(2);
      for (let r = bh.size/2 + 10; r < bh.pullRadius; r += 30) {
        beginShape();
        for (let a = 0; a < TWO_PI; a += PI/10) {
          let xoff = cos(a + bh.rotation * 2) * 5;
          let yoff = sin(a + bh.rotation * 2) * 5;
          vertex(cos(a) * (r + xoff), sin(a) * (r + yoff));
        }
        endShape(CLOSE);
      }
      
      // V·∫Ω ch√¢n tr·ªùi s·ª± ki·ªán
      fill(50, 0, 80, 100);
      noStroke();
      ellipse(0, 0, bh.size * 0.8);
      
      // Hi·ªáu ·ª©ng l√µi
      fill(150, 0, 200, 100);
      ellipse(0, 0, bh.size * 0.5);
      
      // Hi·ªáu ·ª©ng s√°ng
      fill(200, 100, 255, 50);
      ellipse(0, 0, bh.size * 1.2);
      
      pop();
    }
  }

  function drawWorldBorder() {
    // V·∫Ω vi·ªÅn th·∫ø gi·ªõi (ch·ªâ trong phase 1)
    stroke(100, 150, 255);
    strokeWeight(3);
    noFill();
    rect(0, 0, worldWidth, worldHeight);
    
    // V·∫Ω c√°c g√≥c s√°ng
    stroke(150, 200, 255);
    strokeWeight(5);
    // G√≥c tr√™n tr√°i
    line(0, 0, 30, 0);
    line(0, 0, 0, 30);
    // G√≥c tr√™n ph·∫£i
    line(worldWidth, 0, worldWidth - 30, 0);
    line(worldWidth, 0, worldWidth, 30);
    // G√≥c d∆∞·ªõi tr√°i
    line(0, worldHeight, 30, worldHeight);
    line(0, worldHeight, 0, worldHeight - 30);
    // G√≥c d∆∞·ªõi ph·∫£i
    line(worldWidth, worldHeight, worldWidth - 30, worldHeight);
    line(worldWidth, worldHeight, worldWidth, worldHeight - 30);
  }

  function drawStars() {
    for (let star of stars) {
      star.brightness += sin(frameCount * star.twinkle) * 20;
      star.brightness = constrain(star.brightness, 100, 255);
      
      fill(star.brightness, star.brightness, star.brightness);
      noStroke();
      ellipse(star.x, star.y, star.size);
      
      // Hi·ªáu ·ª©ng l·∫•p l√°nh
      if (random() < 0.02) {
        fill(255, 255, 255, 150);
        ellipse(star.x, star.y, star.size * 2);
      }
    }
  }

  function createMeteor() {
    let side = floor(random(4));
    let meteor = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      size: random(3, 8),
      life: 255,
      trail: []
    };
    
    // Xu·∫•t ph√°t t·ª´ c√°c c·∫°nh kh√°c nhau
    switch(side) {
      case 0: // Tr√™n
        meteor.x = random(player.x - width/cameraZoom, player.x + width/cameraZoom);
        meteor.y = player.y - height/(2*cameraZoom);
        meteor.vx = random(-2, 2);
        meteor.vy = random(3, 8);
        break;
      case 1: // Ph·∫£i
        meteor.x = player.x + width/(2*cameraZoom);
        meteor.y = random(player.y - height/cameraZoom, player.y + height/cameraZoom);
        meteor.vx = random(-8, -3);
        meteor.vy = random(-2, 2);
        break;
      case 2: // D∆∞·ªõi
        meteor.x = random(player.x - width/cameraZoom, player.x + width/cameraZoom);
        meteor.y = player.y + height/(2*cameraZoom);
        meteor.vx = random(-2, 2);
        meteor.vy = random(-8, -3);
        break;
      case 3: // Tr√°i
        meteor.x = player.x - width/(2*cameraZoom);
        meteor.y = random(player.y - height/cameraZoom, player.y + height/cameraZoom);
        meteor.vx = random(3, 8);
        meteor.vy = random(-2, 2);
        break;
    }
    
    meteors.push(meteor);
    meteorCount++;
  }

  function updateMeteors() {
    for (let i = meteors.length - 1; i >= 0; i--) {
      let meteor = meteors[i];
      meteor.x += meteor.vx;
      meteor.y += meteor.vy;
      meteor.life -= 2;
      
      // Th√™m v√†o ƒëu√¥i
      meteor.trail.push({x: meteor.x, y: meteor.y, alpha: meteor.life});
      if (meteor.trail.length > 15) {
        meteor.trail.shift();
      }
      
      // X√≥a n·∫øu h·∫øt ƒë·ªùi
      if (meteor.life <= 0) {
        meteors.splice(i, 1);
      }
    }
  }

  function drawMeteors() {
    for (let meteor of meteors) {
      // V·∫Ω ƒëu√¥i sao bƒÉng
      for (let i = 0; i < meteor.trail.length; i++) {
        let point = meteor.trail[i];
        let alpha = map(i, 0, meteor.trail.length - 1, 0, point.alpha);
        fill(255, 200, 100, alpha);
        noStroke();
        ellipse(point.x, point.y, meteor.size * (i / meteor.trail.length));
      }
      
      // V·∫Ω ƒë·∫ßu sao bƒÉng
      fill(255, 255, 200, meteor.life);
      noStroke();
      ellipse(meteor.x, meteor.y, meteor.size);
      
      // Hi·ªáu ·ª©ng s√°ng
      fill(255, 255, 255, meteor.life * 0.3);
      ellipse(meteor.x, meteor.y, meteor.size * 2);
    }
  }

  function createSparkle(x, y) {
    // T·∫°o hi·ªáu ·ª©ng l·∫•p l√°nh khi thu th·∫≠p ƒë·ªìng xu
    // (C√≥ th·ªÉ th√™m sau n·∫øu c·∫ßn)
  }

  function drawPlayer() {
    // V·∫Ω ƒëu√¥i t√†u v≈© tr·ª• v·ªõi m√†u kh√°c nhau khi boost
    if (player.trail.length > 1) {
        for (let i = 0; i < player.trail.length - 1; i++) {
            let alpha = map(i, 0, player.trail.length - 1, 0, 100);
            stroke(isBoosting ? 255 : 0, isBoosting ? 100 : 150, 255, alpha);
            strokeWeight(isBoosting ? 30 : 25); // ƒê·∫≠m h∆°n khi boost
            line(player.trail[i].x, player.trail[i].y, 
                 player.trail[i + 1].x, player.trail[i + 1].y);
        }
    }

    push();
    translate(player.x, player.y);
    
    // Xoay phi thuy·ªÅn theo h∆∞·ªõng di chuy·ªÉn
    rotate(player.rotation);
    
    // Hi·ªáu ·ª©ng b·∫•t t·ª≠ (n·∫øu c√≥)
    if (player.invincible && frameCount % 10 < 5) {
      tint(255, 150); // L√†m nh·∫°t m√†u
    }
    
    imageMode(CENTER);
    image(astronautImg, 0, 0, player.size, player.size);
    pop();
  }

  function updatePlayer() {
    if (controlMode === 'keyboard') {
      updateKeyboardControls();
    } else {
      updateMouseControls();
    }
    
    // √Åp d·ª•ng l·ª±c c·∫£n
    player.vx *= player.drag;
    player.vy *= player.drag;
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠
    player.x += player.vx;
    player.y += player.vy;
    
    // Gi·ªõi h·∫°n trong th·∫ø gi·ªõi
    if (currentPhase === 1) {
      // Trong phase 1, gi·ªõi h·∫°n b·ªüi t∆∞·ªùng
      player.x = constrain(player.x, 30, worldWidth - 30);
      player.y = constrain(player.y, 30, worldHeight - 30);
    } else {
      // Trong phase 2 v√† 3, cho ph√©p di chuy·ªÉn t·ª± do trong th·∫ø gi·ªõi m·ªü r·ªông
      player.x = constrain(player.x, 0, worldWidth);
      player.y = constrain(player.y, 0, worldHeight);
    }
    
    // C·∫≠p nh·∫≠t ƒëu√¥i
    player.trail.push({x: player.x, y: player.y});
    if (player.trail.length > 20) {
      player.trail.shift();
    }
    
    // C·∫≠p nh·∫≠t g√≥c xoay c·ªßa phi thuy·ªÅn
    if (player.vx !== 0 || player.vy !== 0) {
      player.targetRotation = atan2(player.vy, player.vx);
    }
    
    // L√†m m∆∞·ª£t chuy·ªÉn ƒë·ªông xoay
    player.rotation = lerp(player.rotation, player.targetRotation, 0.1);
  }

  function updateKeyboardControls() {
    // X·ª≠ l√Ω boost khi nh·∫•n Shift
    isBoosting = keyIsDown(SHIFT) && energy > 0;
    boostMultiplier = isBoosting ? 3 : 1;
    
    if (isBoosting) {
        energy -= 0.5; // Ti√™u hao nƒÉng l∆∞·ª£ng khi boost
        energy = max(0, energy);
    }
    
    // X·ª≠ l√Ω input v√† v·∫≠t l√Ω bay v·ªõi boost
    if (keyIsDown(LEFT_ARROW)) player.vx -= player.thrust * boostMultiplier;
    if (keyIsDown(RIGHT_ARROW)) player.vx += player.thrust * boostMultiplier;
    if (keyIsDown(UP_ARROW)) player.vy -= player.thrust * boostMultiplier;
    if (keyIsDown(DOWN_ARROW)) player.vy += player.thrust * boostMultiplier;
  }

  function updateMouseControls() {
    // T√≠nh to√°n v·ªã tr√≠ chu·ªôt trong h·ªá t·ªça ƒë·ªô th·∫ø gi·ªõi
    let mouseWorldX = player.x - (width/cameraZoom)/2 + mouseX/cameraZoom;
    let mouseWorldY = player.y - (height/cameraZoom)/2 + mouseY/cameraZoom;
    
    // T√≠nh kho·∫£ng c√°ch v√† h∆∞·ªõng ƒë·∫øn chu·ªôt
    let dx = mouseWorldX - player.x;
    let dy = mouseWorldY - player.y;
    let distance = sqrt(dx*dx + dy*dy);
    
    // X·ª≠ l√Ω boost khi nh·∫•n Shift
    isBoosting = keyIsDown(SHIFT) && energy > 0;
    boostMultiplier = isBoosting ? 3 : 1;
    
    if (isBoosting) {
        energy -= 0.5; // Ti√™u hao nƒÉng l∆∞·ª£ng khi boost
        energy = max(0, energy);
    }
    
    // Di chuy·ªÉn v·ªÅ ph√≠a chu·ªôt n·∫øu ƒë·ªß xa
    if (distance > 20) {
      let speed = player.thrust * boostMultiplier;
      player.vx += (dx / distance) * speed;
      player.vy += (dy / distance) * speed;
    }
    
    // C·∫≠p nh·∫≠t g√≥c xoay ƒë·ªÉ nh√¨n v·ªÅ chu·ªôt
    player.targetRotation = atan2(dy, dx);
  }

  function updateUI() {
    document.getElementById('score').textContent = score;
    
    document.getElementById('energy').textContent = energy;
    
    // C·∫≠p nh·∫≠t ch·ªâ b√°o phase
    let phaseText;
    if (currentPhase === 1) {
      phaseText = 'Giai ƒëo·∫°n 1: Thu th·∫≠p xu 1-10';
    } else if (currentPhase === 2) {
      phaseText = 'Giai ƒëo·∫°n 2: Thu th·∫≠p xu 11-20 (V≈© tr·ª• m·ªü r·ªông)';
    } else {
      phaseText = 'Giai ƒëo·∫°n 3: Thu th·∫≠p xu 21-30 (C·∫©n th·∫≠n l·ªó ƒëen!)';
    }
    document.getElementById('phase-text').textContent = phaseText;
    
    // C·∫≠p nh·∫≠t th·ªùi gian ch∆°i
    if (!gameComplete && !gameOver) {
        gameDuration = millis() - startTime;
    }
    document.getElementById('game-time').textContent = formatTime(gameDuration);

    // Hi·ªÉn th·ªã nƒÉng l∆∞·ª£ng b·∫±ng m√†u s·∫Øc
    let energyElement = document.getElementById('energy');
    if (energy < 20) {
      energyElement.style.color = 'red';
    } else if (energy < 50) {
      energyElement.style.color = 'yellow';
    } else {
      energyElement.style.color = 'lime';
    }
  }

  // üü¢ G·ª¨I ƒêI·ªÇM L√äN SERVER
  function sendScoreToServer() {
    if (scoreSent) return; // ƒê·∫£m b·∫£o ch·ªâ g·ª≠i m·ªôt l·∫ßn
    scoreSent = true;
    
    const username = localStorage.getItem('username') || prompt("Nh·∫≠p t√™n ng∆∞·ªùi ch∆°i c·ªßa b·∫°n:");
    if (username) {
      localStorage.setItem('username', username); // l∆∞u ƒë·ªÉ l·∫ßn sau kh·ªèi h·ªèi l·∫°i
      
      // T√≠nh th·ªùi gian ch∆°i (t√≠nh b·∫±ng gi√¢y)
      let elapsed = Math.round(gameDuration / 1000);
      
      fetch("http://210.245.52.119/api_gamedemso/api/scores/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          username: username,
          gameId: 2,          // id game trong b·∫£ng games, t√πy b·∫°n ƒë·∫∑t
          score: score,
          timeTaken: elapsed
        })
      })
      .then(res => res.json())
      .then(data => {
        console.log("K·∫øt qu·∫£ l∆∞u ƒëi·ªÉm:", data);
        
        // Hi·ªÉn th·ªã k·∫øt qu·∫£ l∆∞u ƒëi·ªÉm
        const resultBox = document.getElementById('result-message');
        resultBox.style.display = 'block';
        
        if (data.success) {
          resultBox.innerHTML = `
            <h2>${gameComplete ? 'Ch√∫c m·ª´ng!' : 'Game Over'}</h2>
            <p>ƒêi·ªÉm c·ªßa b·∫°n: ${score}/30</p>
            <p>Th·ªùi gian: ${formatTime(gameDuration)}</p>
            <p style="color:#10b981">‚úÖ ƒêi·ªÉm ƒë√£ ƒë∆∞·ª£c l∆∞u!</p>
            <p>Nh·∫•n R ƒë·ªÉ ch∆°i l·∫°i</p>
          `;
        } else {
          resultBox.innerHTML = `
            <h2>${gameComplete ? 'Ch√∫c m·ª´ng!' : 'Game Over'}</h2>
            <p>ƒêi·ªÉm c·ªßa b·∫°n: ${score}/30</p>
            <p>Th·ªùi gian: ${formatTime(gameDuration)}</p>
            <p style="color:#ef4444">‚ùå L∆∞u ƒëi·ªÉm th·∫•t b·∫°i: ${data.message}</p>
            <p>Nh·∫•n R ƒë·ªÉ ch∆°i l·∫°i</p>
          `;
        }
      })
      .catch(err => {
        console.error("L·ªói l∆∞u ƒëi·ªÉm:", err);
        
        // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói
        const resultBox = document.getElementById('result-message');
        resultBox.style.display = 'block';
        resultBox.innerHTML = `
          <h2>${gameComplete ? 'Ch√∫c m·ª´ng!' : 'Game Over'}</h2>
          <p>ƒêi·ªÉm c·ªßa b·∫°n: ${score}/30</p>
          <p>Th·ªùi gian: ${formatTime(gameDuration)}</p>
          <p style="color:#ef4444">‚ö†Ô∏è Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c server.</p>
          <p>Nh·∫•n R ƒë·ªÉ ch∆°i l·∫°i</p>
        `;
      });
    } else {
      // Ng∆∞·ªùi ch∆°i kh√¥ng nh·∫≠p t√™n
      const resultBox = document.getElementById('result-message');
      resultBox.style.display = 'block';
      resultBox.innerHTML = `
        <h2>${gameComplete ? 'Ch√∫c m·ª´ng!' : 'Game Over'}</h2>
        <p>ƒêi·ªÉm c·ªßa b·∫°n: ${score}/30</p>
        <p>Th·ªùi gian: ${formatTime(gameDuration)}</p>
        <p style="color:#facc15">‚ö†Ô∏è Kh√¥ng l∆∞u ƒëi·ªÉm (ch∆∞a nh·∫≠p t√™n).</p>
        <p>Nh·∫•n R ƒë·ªÉ ch∆°i l·∫°i</p>
      `;
    }
  }

  function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
  }
  </script>
</body>
</html>