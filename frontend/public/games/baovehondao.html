<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Flying + Stable Movement (Knight) - N√©m Th∆∞∆°ng vs T√†u Chi·∫øn</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      font-family: sans-serif;
      font-size: 13px;
      border-radius: 5px;
      z-index: 1000;
    }
    .controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      font-family: sans-serif;
      font-size: 13px;
      border-radius: 5px;
      z-index: 1000;
    }
    .crosshair {
      position: absolute;
      top: 54%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1000;
    }
    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
    }
    .crosshair::before {
      width: 20px;
      height: 2px;
      top: -1px;
      left: -10px;
    }
    .crosshair::after {
      width: 2px;
      height: 20px;
      top: -10px;
      left: -1px;
    }
    .crosshair-dot {
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      position: absolute;
      top: -2px;
      left: -2px;
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
    }
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      font-family: sans-serif;
      font-size: 24px;
      border-radius: 10px;
      text-align: center;
      display: none;
      z-index: 2000;
    }
    .health-bar {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 20px;
      background: rgba(0,0,0,0.6);
      border-radius: 5px;
      overflow: hidden;
      z-index: 1000;
    }
    .health-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
      transition: width 0.3s;
    }
    .ship-health {
      position: absolute;
      bottom: 50px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      font-family: sans-serif;
      font-size: 13px;
      border-radius: 5px;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="info">Click v√†o canvas ƒë·ªÉ lock chu·ªôt ‚Äî WASD: di chuy·ªÉn ‚Äî Space/‚Üë: l√™n ‚Äî ‚Üì: xu·ªëng ‚Äî Esc ƒë·ªÉ unlock</div>
  <div class="controls">
    Click chu·ªôt tr√°i ƒë·ªÉ n√©m th∆∞∆°ng th·∫≥ng theo h∆∞·ªõng nh√¨n
    <br>Killed: <span id="killCounter">0</span> qu√°i v·∫≠t
    <br>Health: <span id="playerHealth">3</span> / 3
  </div>
  
  <div class="health-bar">
    <div class="health-fill" id="playerHealthBar" style="width: 100%;"></div>
  </div>
  
  <div class="ship-health">
    Target Ship: <span id="targetShip">1</span> | Health: <span id="shipHealth">100</span> / 100
  </div>

  <div class="game-over" id="gameOver">
    Game Over!<br>
    <button id="restartButton" style="margin-top: 10px; padding: 5px 10px;">Restart</button>
  </div>

  <!-- Crosshair t√¢m ng·∫Øm -->
  <div class="crosshair">
    <div class="crosshair-dot"></div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "GLTFLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'GLTFLoader';

    // Scene / Renderer / Camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0c8ff);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.set(0, 40, -18);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    hemi.position.set(0, 200, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(50, 200, 100);
    dir.castShadow = true;
    scene.add(dir);

    // Raycaster d√πng cho aim (t√¢m m√†n h√¨nh)
    const raycaster = new THREE.Raycaster();

    // Nh√¢n v·∫≠t: knight.glb
    let character;
    const loader = new GLTFLoader();
    
    // Bi·∫øn tr·∫°ng th√°i game
    let playerHealth = 3;
    let isGameOver = false;
    let targetShipNumber = 1;
    let shipHealth = 100;
    
    // C·∫≠p nh·∫≠t UI
    function updateUI() {
      document.getElementById('playerHealth').textContent = playerHealth;
      document.getElementById('playerHealthBar').style.width = `${(playerHealth / 3) * 100}%`;
      document.getElementById('targetShip').textContent = targetShipNumber;
      document.getElementById('shipHealth').textContent = shipHealth;
    }
    
    // Game over
    function gameOver() {
      isGameOver = true;
      document.getElementById('gameOver').style.display = 'block';
      document.exitPointerLock();
    }
    
    // Restart game
    document.getElementById('restartButton').addEventListener('click', () => {
      location.reload();
    });
    
    loader.load('knight.glb', (gltf) => {
      character = gltf.scene;
      character.traverse((obj) => {
        if (obj.isMesh) {
          obj.castShadow = true;
          obj.receiveShadow = true;
        }
      });
      // Thu nh·ªè l·∫°i nhi·ªÅu h∆°n
      character.scale.set(0.05, 0.05, 0.05);
      // ƒê·∫∑t v·ªã tr√≠ ban ƒë·∫ßu
      character.position.set(200, 200, -200);
      // Quay l∆∞ng v·ªÅ ph√≠a m√†n h√¨nh
      character.rotation.set(0, Math.PI, 0);

      scene.add(character);
      
      // Spawn qu√°i v·∫≠t sau khi nh√¢n v·∫≠t ƒë∆∞·ª£c t·∫£i
      setTimeout(() => spawnMonsters(), 1000);
    }, undefined, (err) => console.error('Load knight error', err));

    // Load map (n·∫øu c√≥)
    loader.load('sea_keep_lonely_watcher.glb', (gltf) => {
      const envRoot = gltf.scene;
      envRoot.traverse((obj) => {
        if (obj.isMesh) {
          obj.castShadow = true;
          obj.receiveShadow = true;
          if (obj.material) {
            obj.material.depthWrite = true;
            obj.material.depthTest = true;
            if (obj.material.transparent) obj.material.transparent = false;
            obj.material.polygonOffset = true;
            obj.material.polygonOffsetFactor = 1;
            obj.material.polygonOffsetUnits = 1;
          }
        }
      });
      scene.add(envRoot);
    }, undefined, (err) => console.warn('Load map error', err));

    // Input
    const keys = {};
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (['Space','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();
    });
    window.addEventListener('keyup', (e) => keys[e.code] = false);

    // Mouse look
    let yaw = 0;
    let pitch = 0;
    const mouseSensitivity = 0.0025;
    renderer.domElement.addEventListener('click', () => {
      if (!isGameOver) {
        renderer.domElement.requestPointerLock();
      }
    });
    window.addEventListener('mousemove', (e) => {
      if (document.pointerLockElement === renderer.domElement && !isGameOver) {
        yaw -= e.movementX * mouseSensitivity;
        pitch -= e.movementY * mouseSensitivity;
      }
    });

    // Movement physics
    const MAX_SPEED = 60;
    const ACCEL = 20.0;
    const VERT_MAX = 40;
    const VERT_ACCEL = 18.0;
    const CAMERA_SMOOTH = 10.0;

    const velocity = new THREE.Vector3(0, 0, 0);
    let velY = 0;

    const clock = new THREE.Clock();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // H·ªá th·ªëng v≈© kh√≠
    const spears = []; // M·∫£ng l∆∞u tr·ªØ c√°c c√¢y th∆∞∆°ng
    const SPEAR_SPEED = 300; // TƒÉng t·ªëc ƒë·ªô th∆∞∆°ng
    const MAX_SPEARS = 20; // TƒÉng s·ªë l∆∞·ª£ng th∆∞∆°ng t·ªëi ƒëa
    let spearCount = 0; // ƒê·∫øm s·ªë th∆∞∆°ng ƒë√£ n√©m
    
    // H·ªá th·ªëng ƒë·∫°n c·ªßa t√†u
    const cannonBalls = [];
    const CANNON_BALL_SPEED = 100;
    let lastCannonFireTime = 0;
    const CANNON_FIRE_INTERVAL = 10000; // 10 gi√¢y
    
    // T·∫°o hi·ªáu ·ª©ng n·ªï
    function createExplosion(position) {
      const particles = [];
      for (let i = 0; i < 10; i++) {
        const particleGeometry = new THREE.SphereGeometry(0.3, 6, 4);
        const particleMaterial = new THREE.MeshPhongMaterial({ 
          color: new THREE.Color().setHSL(Math.random() * 0.1, 1, 0.5) // M√†u cam/v√†ng
        });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        particle.position.copy(position);
        
        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 40,
          Math.random() * 30 + 10,
          (Math.random() - 0.5) * 40
        );
        
        scene.add(particle);
        particles.push({ mesh: particle, velocity, life: 1 });
      }
      
      // C·∫≠p nh·∫≠t v√† x√≥a particles
      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.mesh.position.add(p.velocity.clone().multiplyScalar(0.016));
          p.velocity.y -= 30 * 0.016; // Gravity
          p.life -= 0.016;
          
          if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
          }
        }
        
        if (particles.length > 0) {
          requestAnimationFrame(updateParticles);
        }
      }
      updateParticles();
    }
    
    // T·∫°o m√¥ h√¨nh th∆∞∆°ng
    function createSpear() {
      const spearGroup = new THREE.Group();
      
      // Th√¢n th∆∞∆°ng (chi·ªÅu d·ªçc theo tr·ª•c Y)
      const shaftGeometry = new THREE.CylinderGeometry(0.4, 0.4, 15, 15);
      const shaftMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
      const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
      shaft.position.y = 0;
      spearGroup.add(shaft);
      
      // ƒê·∫ßu th∆∞∆°ng (n·∫±m ·ªü ph√≠a d∆∞∆°ng Y)
      const headGeometry = new THREE.ConeGeometry(0.6, 4, 14);
      const headMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 8;
      spearGroup.add(head);
      
      // ƒêu√¥i th∆∞∆°ng
      const tailGeometry = new THREE.ConeGeometry(0.2, 2, 8);
      const tailMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
      const tail = new THREE.Mesh(tailGeometry, tailMaterial);
      tail.position.y = -7.75;
      tail.rotation.x = Math.PI;
      spearGroup.add(tail);
      
      return spearGroup;
    }
    
    // T·∫°o ƒë·∫°n ph√°o (h√¨nh c·∫ßu)
    function createCannonBall() {
      const geometry = new THREE.SphereGeometry(3, 16, 16);
      const material = new THREE.MeshPhongMaterial({ color: 0x000000 });
      const cannonBall = new THREE.Mesh(geometry, material);
      return cannonBall;
    }
    
    // H√†m t√≠nh h∆∞·ªõng n√©m th∆∞∆°ng ch√≠nh x√°c: d√πng Raycaster t·ª´ t√¢m m√†n h√¨nh (crosshair)
    function getThrowDirection() {
      // Raycaster setFromCamera v·ªõi (0,0) -> ch√≠nh gi·ªØa m√†n h√¨nh
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      return raycaster.ray.direction.clone().normalize();
    }
    
    // H√†m n√©m th∆∞∆°ng - BAY THEO H∆Ø·ªöNG T√ÇM NG·∫ÆM
    function throwSpear() {
      if (!character || isGameOver) return;
      if (spearCount >= MAX_SPEARS) return;
      
      const spear = createSpear();
      
      // H∆∞·ªõng n√©m l·∫•y t·ª´ camera (ch√≠nh gi·ªØa m√†n h√¨nh)
      const throwDirection = getThrowDirection(); // unit vector
      
      // Spawn th∆∞∆°ng ph√≠a tr∆∞·ªõc nh√¢n v·∫≠t, nh∆∞ng bay theo h∆∞·ªõng c·ªßa camera (crosshair)
      const spawnOffset = new THREE.Vector3(0, 2, 0); // n√¢ng l√™n 2 ƒë·ªÉ kh√¥ng ch·∫°m ƒë·∫•t
      const spawn = character.position.clone().add(spawnOffset).add(throwDirection.clone().multiplyScalar(3));
      spear.position.copy(spawn);
      
      // ƒê·ªãnh h∆∞·ªõng th∆∞∆°ng nh√¨n theo h∆∞·ªõng bay (lookAt)
      spear.lookAt(spawn.clone().add(throwDirection));
      // Do m√¥ h√¨nh th∆∞∆°ng n·∫±m theo tr·ª•c Y, xoay -90 ƒë·ªô ƒë·ªÉ m≈©i tr·ªè ra h∆∞·ªõng front.
      spear.rotateX(-Math.PI / 2);
      
      scene.add(spear);
      spears.push({
        mesh: spear,
        velocity: throwDirection.clone().multiplyScalar(SPEAR_SPEED),
        lifeTime: 0,
        maxLifeTime: 8 // TƒÉng th·ªùi gian t·ªìn t·∫°i
      });
      
      spearCount++;
    }
    
    // X·ª≠ l√Ω click chu·ªôt ƒë·ªÉ n√©m th∆∞∆°ng
    window.addEventListener('mousedown', (e) => {
      if (e.button === 0 && document.pointerLockElement === renderer.domElement && !isGameOver) {
        throwSpear();
      }
    });
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ c√°c th∆∞∆°ng
    function updateSpears(dt) {
      for (let i = spears.length - 1; i >= 0; i--) {
        const spear = spears[i];
        
        // Di chuy·ªÉn th∆∞∆°ng theo v·∫≠n t·ªëc
        spear.mesh.position.add(spear.velocity.clone().multiplyScalar(dt));
        spear.lifeTime += dt;
        
        // Hi·ªáu ·ª©ng xoay nh·∫π khi bay
        spear.mesh.rotateZ(dt * 10);
        
        // Ki·ªÉm tra va ch·∫°m v·ªõi t√†u
        let hitShip = false;
        for (let ship of ships) {
          if (ship.mesh && ship.health > 0 && ship.number === targetShipNumber) {
            const distance = spear.mesh.position.distanceTo(ship.mesh.position);
            if (distance < 30) { // Kho·∫£ng c√°ch va ch·∫°m
              // G√¢y s√°t th∆∞∆°ng cho t√†u
              ship.health -= 10;
              shipHealth = ship.health;
              updateUI();
              
              // T·∫°o hi·ªáu ·ª©ng n·ªï
              createExplosion(spear.mesh.position);
              
              // Ki·ªÉm tra n·∫øu t√†u b·ªã ti√™u di·ªát
              if (ship.health <= 0) {
                // Chuy·ªÉn sang t√†u ti·∫øp theo
                targetShipNumber++;
                if (targetShipNumber > 10) targetShipNumber = 1; // Quay l·∫°i t√†u 1 n·∫øu ƒë√£ h·∫øt
                
                // C·∫≠p nh·∫≠t m√°u c·ªßa t√†u m·ªõi
                const nextShip = ships.find(s => s.number === targetShipNumber);
                shipHealth = nextShip ? nextShip.health : 100;
                updateUI();
              }
              
              hitShip = true;
              break;
            }
          }
        }
        
        // X√≥a th∆∞∆°ng n·∫øu h·∫øt th·ªùi gian, ra kh·ªèi t·∫ßm nh√¨n ho·∫∑c tr√∫ng t√†u
        if (spear.lifeTime > spear.maxLifeTime || 
            spear.mesh.position.distanceTo(character.position) > 800 ||
            hitShip) {
          scene.remove(spear.mesh);
          spears.splice(i, 1);
          spearCount--;
        }
      }
    }
    
    // H√†m b·∫Øn ƒë·∫°n t·ª´ t√†u
    function fireCannonFromShips() {
      if (!character || isGameOver) return;
      
      // Ch·ªçn ng·∫´u nhi√™n 3 t√†u ƒë·ªÉ b·∫Øn
      const activeShips = ships.filter(ship => ship.mesh && ship.health > 0);
      if (activeShips.length === 0) return;
      
      // Ch·ªçn ng·∫´u nhi√™n 3 t√†u (ho·∫∑c √≠t h∆°n n·∫øu kh√¥ng ƒë·ªß)
      const shipsToFire = [];
      const indices = [];
      
      while (indices.length < Math.min(3, activeShips.length)) {
        const randomIndex = Math.floor(Math.random() * activeShips.length);
        if (!indices.includes(randomIndex)) {
          indices.push(randomIndex);
          shipsToFire.push(activeShips[randomIndex]);
        }
      }
      
      // M·ªói t√†u b·∫Øn 1 vi√™n ƒë·∫°n v·ªÅ ph√≠a nh√¢n v·∫≠t
      for (let ship of shipsToFire) {
        const cannonBall = createCannonBall();
        cannonBall.position.copy(ship.mesh.position);
        
        // H∆∞·ªõng b·∫Øn v·ªÅ ph√≠a nh√¢n v·∫≠t
        const direction = character.position.clone().sub(ship.mesh.position).normalize();
        
        scene.add(cannonBall);
        cannonBalls.push({
          mesh: cannonBall,
          velocity: direction.multiplyScalar(CANNON_BALL_SPEED),
          lifeTime: 0,
          maxLifeTime: 15
        });
      }
    }
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ ƒë·∫°n ph√°o
    function updateCannonBalls(dt) {
      for (let i = cannonBalls.length - 1; i >= 0; i--) {
        const cannonBall = cannonBalls[i];
        
        // Di chuy·ªÉn ƒë·∫°n theo v·∫≠n t·ªëc
        cannonBall.mesh.position.add(cannonBall.velocity.clone().multiplyScalar(dt));
        cannonBall.lifeTime += dt;
        
        // Ki·ªÉm tra va ch·∫°m v·ªõi nh√¢n v·∫≠t
        if (character) {
          const distance = cannonBall.mesh.position.distanceTo(character.position);
          if (distance < 10) { // Kho·∫£ng c√°ch va ch·∫°m
            // Tr·ª´ m√°u nh√¢n v·∫≠t
            playerHealth--;
            updateUI();
            
            // T·∫°o hi·ªáu ·ª©ng n·ªï
            createExplosion(cannonBall.mesh.position);
            
            // Ki·ªÉm tra game over
            if (playerHealth <= 0) {
              gameOver();
            }
            
            // X√≥a ƒë·∫°n
            scene.remove(cannonBall.mesh);
            cannonBalls.splice(i, 1);
            continue;
          }
        }
        
        // X√≥a ƒë·∫°n n·∫øu h·∫øt th·ªùi gian ho·∫∑c ra kh·ªèi t·∫ßm nh√¨n
        if (cannonBall.lifeTime > cannonBall.maxLifeTime || 
            cannonBall.mesh.position.distanceTo(character.position) > 800) {
          scene.remove(cannonBall.mesh);
          cannonBalls.splice(i, 1);
        }
      }
    }

    // üö¢ T·∫°o nhi·ªÅu t√†u b∆°i quanh ƒë·∫£o
    const ships = [];
    const NUM_SHIPS = 10;
    const shipRadiusBase = 350;

    for (let i = 1; i <= NUM_SHIPS; i++) {
      loader.load('ship.glb', (gltf) => {
        const ship = gltf.scene;
        ship.scale.set(0.01, 0.01, 0.01);

        const angle = (i / NUM_SHIPS) * Math.PI * 2;
        const radius = shipRadiusBase + i * 20;
        ship.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);

        // üè∑Ô∏è Canvas v·∫Ω s·ªë
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 256;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 150px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i.toString(), 128, 128);

        const tex = new THREE.CanvasTexture(canvas);
        const labelMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
        const label = new THREE.Sprite(labelMat);
        label.scale.set(40, 40, 1);   // lu√¥n to, kh√¥ng b·ªã scale theo t√†u
        scene.add(label);

        scene.add(ship);

        ships.push({
          mesh: ship,
          label: label,
          angle: angle,
          radius: radius,
          speed: 0.001 + i * 0.01,
          number: i,
          health: 100
        });
        
        // C·∫≠p nh·∫≠t UI l·∫ßn ƒë·∫ßu
        updateUI();
      });
    }

    function smoothingFactor(rate, dt) {
      return 1 - Math.exp(-rate * dt);
    }

    // Main loop
    function animate() {
      if (isGameOver) return;
      
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      
      // Ki·ªÉm tra th·ªùi gian b·∫Øn ƒë·∫°n
      const currentTime = Date.now();
      if (currentTime - lastCannonFireTime > CANNON_FIRE_INTERVAL) {
        fireCannonFromShips();
        lastCannonFireTime = currentTime;
      }

      if (character) {
        // yaw xoay nh√¢n v·∫≠t
        character.rotation.set(0, yaw, 0);

        // Input local
        let inputX = 0, inputZ = 0;
        if (keys['KeyW']) inputZ -= 1;
        if (keys['KeyS']) inputZ += 1;
        if (keys['KeyA']) inputX -= 1;
        if (keys['KeyD']) inputX += 1;

        const inputLen = Math.hypot(inputX, inputZ);
        if (inputLen > 0) {
          inputX /= inputLen;
          inputZ /= inputLen;
        }

        const localInput = new THREE.Vector3(-inputX, 0, -inputZ);
        const worldDir = localInput.applyQuaternion(character.quaternion);

        const targetVelXZ = new THREE.Vector3(worldDir.x * MAX_SPEED, 0, worldDir.z * MAX_SPEED);

        const s = smoothingFactor(ACCEL, dt);
        velocity.x = THREE.MathUtils.lerp(velocity.x, targetVelXZ.x, s);
        velocity.z = THREE.MathUtils.lerp(velocity.z, targetVelXZ.z, s);

        let targetVy = 0;
        if (keys['Space'] || keys['ArrowUp']) targetVy = VERT_MAX;
        else if (keys['ArrowDown']) targetVy = -VERT_MAX;

        const sv = smoothingFactor(VERT_ACCEL, dt);
        velY = THREE.MathUtils.lerp(velY, targetVy, sv);

        const moveStep = velocity.clone().multiplyScalar(dt);
        character.position.add(moveStep);
        character.position.y += velY * dt;

        if (character.position.y < -200) character.position.y = -200;

        const camOffset = new THREE.Vector3(-6, 20, -32);
        const camOffsetWorld = camOffset.clone().applyQuaternion(character.quaternion);
        const desiredCamPos = character.position.clone().add(camOffsetWorld);

        const cs = smoothingFactor(CAMERA_SMOOTH, dt);
        camera.position.lerp(desiredCamPos, cs);

        const lookTarget = character.position.clone().add(new THREE.Vector3(0, pitch * 10, 0));
        camera.lookAt(lookTarget);
        
        // C·∫≠p nh·∫≠t th∆∞∆°ng
        updateSpears(dt);
        
        // C·∫≠p nh·∫≠t ƒë·∫°n ph√°o
        updateCannonBalls(dt);

        // üö¢ Update t√†u
        for (let s of ships) {
          if (!s.mesh) continue;
          
          s.angle += dt * s.speed;
          s.mesh.position.set(
            Math.cos(s.angle) * s.radius,
            0,
            Math.sin(s.angle) * s.radius
          );
          s.mesh.lookAt(0, 0, 0);
          s.mesh.rotateY(Math.PI / 2);

          // üìå c·∫≠p nh·∫≠t s·ªë ·ªü tr√™n t√†u
          if (s.label) {
            s.label.position.copy(s.mesh.position).add(new THREE.Vector3(0, 30, 0));
          }
        }
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>