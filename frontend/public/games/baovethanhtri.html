<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Game B·∫£o V·ªá Th√†nh - S·ªë Ti·∫øp Theo</title>
  <style>
    body { margin: 0; background: #222; color: white; text-align: center; font-family: sans-serif; }
    canvas { background: #333; display: block; margin: 10px auto; border: 2px solid #666; }
    #questionBox {
      background: #444;
      padding: 15px;
      margin: 10px auto;
      width: 500px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .answerBtn {
      background: #666;
      color: white;
      border: none;
      padding: 12px 25px;
      margin: 5px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s;
    }
    .answerBtn:hover {
      background: #888;
      transform: translateY(-2px);
    }
    .answerBtn:disabled {
      background: #333;
      cursor: not-allowed;
      opacity: 0.5;
    }
    #gameInfo {
      margin: 10px 0;
      font-size: 18px;
    }
    #skillButtons {
      margin: 15px auto;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .skillBtn {
      background: linear-gradient(45deg, #ff9800, #ff5722);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .skillBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    .skillBtn:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }
    .skillProgress {
      margin-top: 5px;
      font-size: 12px;
    }
    #result-box {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 1000;
      box-shadow: 0 0 20px rgba(255,255,255,0.2);
      min-width: 300px;
    }
    .hidden {
      display: none;
    }
    #restartBtn {
      background: linear-gradient(45deg, #4CAF50, #2E7D32);
      color: white;
      border: none;
      padding: 12px 25px;
      margin-top: 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.3s;
    }
    #restartBtn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
  </style>
</head>
<body>
  <h2>üè∞ Game B·∫£o V·ªá Th√†nh - S·ªë Ti·∫øp Theo üè∞</h2>
  <div id="gameInfo">
    <span id="hpDisplay">‚ù§Ô∏è HP Th√†nh: 100</span> | 
    <span id="scoreDisplay">‚≠ê ƒêi·ªÉm: 0</span> |
    <span id="timeDisplay">‚è±Ô∏è Th·ªùi gian: 0s</span>
  </div>
  
  <div id="skillButtons">
    <button id="rainSkill" class="skillBtn" disabled>M∆∞a ƒê·∫°n (6 c√¢u ƒë√∫ng)</button>
    <button id="pierceSkill" class="skillBtn" disabled>ƒê·∫°n Th·∫ßn (10 c√¢u ƒë√∫ng)</button>
  </div>
  
  <canvas id="gameCanvas" width="1000" height="500"></canvas>

  <div id="questionBox">
    <p id="question">C√¢u h·ªèi s·∫Ω hi·ªán ·ªü ƒë√¢y</p>
    <div id="answers"></div>
    <div id="feedback" style="margin-top: 10px; font-weight: bold;"></div>
  </div>

  <div id="result-box" class="hidden">
    <!-- K·∫øt qu·∫£ game s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
    <button id="restartBtn">Ch∆°i L·∫°i</button>
  </div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let castleHP = 100;
let enemies = [];
let bullets = [];
let currentQuestion = {};
let score = 0;
let gameRunning = true;
let questionLocked = false;

// Bi·∫øn k·ªπ nƒÉng
let correctStreak = 0; // S·ªë c√¢u tr·∫£ l·ªùi ƒë√∫ng li√™n ti·∫øp
let doubleShotActive = false; // K·ªπ nƒÉng b·∫Øn ƒë√¥i

// Bi·∫øn th·ªùi gian
let startTime = null;
let currentTime = 0;
let timerInterval = null;

// Bi·∫øn tƒÉng m√°u qu√°i v·∫≠t
let enemyHpBonus = 0;
let enemyHpInterval;

// Load images
const images = {};
const imageFiles = [
  'backgroundthanhtri.png',
  'castle.png',
  'hero.png',
  'arrow.png',
  'monster1.png',
  'monster2.png',
  'monster3.png',
  'monster4.png',
  'monster5.png',
  'monster6.png',
  'monster7.png',
  'monster8.png'
];

let imagesLoaded = 0;
imageFiles.forEach(filename => {
  const img = new Image();
  img.onload = () => {
    imagesLoaded++;
    if (imagesLoaded === imageFiles.length) {
      console.log('T·∫•t c·∫£ h√¨nh ·∫£nh ƒë√£ ƒë∆∞·ª£c t·∫£i!');
    }
  };
  img.onerror = () => {
    console.log(`Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh: ${filename}`);
    imagesLoaded++;
  };
  img.src = filename;
  images[filename] = img;
});

// Nh√¢n v·∫≠t tr√™n th√†nh
const hero = { x: 120, y: 220 };

// Enemy class
class Enemy {
  constructor() {
    this.x = canvas.width;
    
    // Qu√°i v·∫≠t xu·∫•t hi·ªán ·ªü c√°c ƒë·ªô cao kh√°c nhau
    const laneHeights = [280, 330, 380];
    this.lane = Math.floor(Math.random() * laneHeights.length);
    this.y = laneHeights[this.lane];
    
    this.hp = 80 + enemyHpBonus;
    this.maxHP = 80 + enemyHpBonus;
    this.speed = 0.4;
    this.width = 80;
    this.height = 100;
    
    // Ch·ªçn ng·∫´u nhi√™n m·ªôt trong 8 con qu√°i v·∫≠t
    this.monsterType = Math.floor(Math.random() * 8) + 1;
    this.image = images[`monster${this.monsterType}.png`];
    
    // Bi·∫øn ƒë·ªÉ t·∫°o ƒë∆∞·ªùng ƒëi ziczac
    this.zigzagOffset = 0;
    this.zigzagSpeed = Math.random() * 0.05 + 0.02;
    this.zigzagAmplitude = 30;
    
    // Bi·∫øn ƒë·ªÉ t·∫°o ƒë∆∞·ªùng ƒëi l∆∞·ª£n s√≥ng
    this.waveOffset = Math.random() * Math.PI * 2;
    this.waveSpeed = Math.random() * 0.03 + 0.01;
    this.waveAmplitude = 40;
    
    // Ch·ªçn ki·ªÉu di chuy·ªÉn ng·∫´u nhi√™n
    this.movementType = Math.floor(Math.random() * 3); // 0: th·∫≥ng, 1: ziczac, 2: l∆∞·ª£n s√≥ng
  }
  
  update() {
    // Di chuy·ªÉn theo chi·ªÅu ngang
    this.x -= this.speed;
    
    // Di chuy·ªÉn theo chi·ªÅu d·ªçc d·ª±a tr√™n ki·ªÉu di chuy·ªÉn
    if (this.movementType === 1) {
      // Di chuy·ªÉn ziczac
      this.zigzagOffset += this.zigzagSpeed;
      this.y = 330 + Math.sin(this.zigzagOffset) * this.zigzagAmplitude;
    } else if (this.movementType === 2) {
      // Di chuy·ªÉn l∆∞·ª£n s√≥ng
      this.waveOffset += this.waveSpeed;
      this.y = 330 + Math.sin(this.waveOffset) * this.waveAmplitude;
    }
    // N·∫øu movementType = 0, qu√°i v·∫≠t di chuy·ªÉn th·∫≥ng (kh√¥ng thay ƒë·ªïi y)
    
    if (this.x < 160) { // Va ch·∫°m v·ªõi th√†nh
      castleHP -= 15;
      this.hp = 0;
    }
  }
  
  draw() {
    // V·∫Ω qu√°i v·∫≠t
    if (this.image && this.image.complete) {
      ctx.drawImage(this.image, this.x, this.y - this.height, this.width, this.height);
    } else {
      // Fallback n·∫øu kh√¥ng load ƒë∆∞·ª£c h√¨nh
      ctx.fillStyle = `hsl(${this.monsterType * 45}, 70%, 50%)`;
      ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
    }
    
    // Thanh m√°u
    const hpBarWidth = this.width;
    const hpBarHeight = 4;
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(this.x, this.y - this.height - 8, hpBarWidth, hpBarHeight);
    
    ctx.fillStyle = this.hp > this.maxHP * 0.3 ? "green" : "red";
    const hpWidth = (this.hp / this.maxHP) * hpBarWidth;
    ctx.fillRect(this.x, this.y - this.height - 8, hpWidth, hpBarHeight);
  }
}

// Bullet class
class Bullet {
  constructor(target, specialType = null) {
    this.x = hero.x + 30;
    this.y = hero.y + 10;
    this.target = target;
    this.speed = 6;
    this.hit = false;
    this.width = 40;
    this.height = 17;
    this.createdTime = Date.now();
    this.lifetime = 3000; // 3 gi√¢y
    this.specialType = specialType; // 'rain' ho·∫∑c 'pierce'
  }
  
  update() {
    // Ki·ªÉm tra th·ªùi gian s·ªëng
    if (Date.now() - this.createdTime > this.lifetime) {
      this.hit = true; // ƒê√°nh d·∫•u ƒë·ªÉ x√≥a
      return;
    }
    
    // ƒê·∫°n th∆∞·ªùng
    if (!this.target || this.target.hp <= 0) {
      // N·∫øu kh√¥ng c√≥ target, bay th·∫≥ng v·ªÅ ph√≠a tr∆∞·ªõc
      this.x += this.speed;
      if (this.x > canvas.width) {
        this.hit = true;
      }
      return;
    }
    
    let dx = this.target.x - this.x;
    let dy = this.target.y - 20 - this.y;
    let dist = Math.hypot(dx, dy);
    
    if (dist < 25) {
      this.target.hp -= 25;
      this.hit = true;
    } else {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }
  }
  
  draw() {
    if (images['arrow.png'] && images['arrow.png'].complete) {
      // ƒê·∫°n th∆∞·ªùng
      ctx.drawImage(images['arrow.png'], this.x - this.width/2, this.y - this.height/2, this.width, this.height);
    } else {
      // Fallback
      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// H√†m b·∫Øt ƒë·∫ßu t√≠nh th·ªùi gian
function startTimer() {
  startTime = performance.now();
  timerInterval = setInterval(updateTimer, 100);
}

// H√†m c·∫≠p nh·∫≠t th·ªùi gian
function updateTimer() {
  if (startTime) {
    currentTime = (performance.now() - startTime) / 1000;
    document.getElementById("timeDisplay").innerText = `‚è±Ô∏è Th·ªùi gian: ${currentTime.toFixed(1)}s`;
  }
}

// H√†m d·ª´ng t√≠nh th·ªùi gian
function stopTimer() {
  clearInterval(timerInterval);
  timerInterval = null;
}

// H√†m tƒÉng m√°u qu√°i v·∫≠t m·ªói 30 gi√¢y
function startEnemyHpIncrease() {
  enemyHpInterval = setInterval(() => {
    enemyHpBonus += 10;
    console.log(`Qu√°i v·∫≠t tƒÉng s·ª©c m·∫°nh! +10 HP (T·ªïng: ${enemyHpBonus})`);
  }, 30000); // 30 gi√¢y
}

// H√†m k·∫øt th√∫c game
function endGame(isWin) {
  stopTimer();
  clearInterval(enemyHpInterval);
  const elapsed = startTime ? (performance.now() - startTime)/1000 : 0;
  
  const resultBox = document.getElementById('result-box');
  resultBox.classList.remove('hidden');
  
  if (isWin) {
    resultBox.innerHTML = `üéâ Ho√†n th√†nh! ƒêi·ªÉm: <span style="color:gold">${score}</span> ‚Äî Th·ªùi gian: <strong>${elapsed.toFixed(2)}s</strong>`;
  } else {
    resultBox.innerHTML = `üí• Game Over! ƒêi·ªÉm: <span style="color:gold">${score}</span> ‚Äî Th·ªùi gian: <strong>${elapsed.toFixed(2)}s</strong>`;
  }

  // üü¢ G·ª¨I ƒêI·ªÇM L√äN SERVER
  const username = localStorage.getItem('username') || prompt("Nh·∫≠p t√™n ng∆∞·ªùi ch∆°i c·ªßa b·∫°n:");
  if (username) {
    localStorage.setItem('username', username); // l∆∞u ƒë·ªÉ l·∫ßn sau kh·ªèi h·ªèi l·∫°i
    fetch("http://210.245.52.119/api_gamedemso/api/scores/save", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        username: username,
        gameId: 13,          // id game trong b·∫£ng games, t√πy b·∫°n ƒë·∫∑t
        score: score,
        timeTaken: elapsed
      })
    })
    .then(res => res.json())
    .then(data => {
      console.log("K·∫øt qu·∫£ l∆∞u ƒëi·ªÉm:", data);
      if (data.success) {
        resultBox.innerHTML += "<br><span style='color:#10b981'>‚úÖ ƒêi·ªÉm ƒë√£ ƒë∆∞·ª£c l∆∞u!</span>";
      } else {
        resultBox.innerHTML += "<br><span style='color:#ef4444'>‚ùå L∆∞u ƒëi·ªÉm th·∫•t b·∫°i: " + data.message + "</span>";
      }
    })
    .catch(err => {
      console.error("L·ªói l∆∞u ƒëi·ªÉm:", err);
      resultBox.innerHTML += "<br><span style='color:#ef4444'>‚ö†Ô∏è Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c server.</span>";
    });
  } else {
    resultBox.innerHTML += "<br><span style='color:#facc15'>‚ö†Ô∏è Kh√¥ng l∆∞u ƒëi·ªÉm (ch∆∞a nh·∫≠p t√™n).</span>";
  }
  
  // Th√™m n√∫t ch∆°i l·∫°i
  resultBox.innerHTML += '<br><button id="restartBtn">Ch∆°i L·∫°i</button>';
  document.getElementById("restartBtn").addEventListener("click", restartGame);
}

// H√†m kh·ªüi ƒë·ªông l·∫°i game
function restartGame() {
  // Reset t·∫•t c·∫£ bi·∫øn
  castleHP = 100;
  enemies = [];
  bullets = [];
  score = 0;
  gameRunning = true;
  questionLocked = false;
  correctStreak = 0;
  doubleShotActive = false;
  startTime = null;
  currentTime = 0;
  enemyHpBonus = 0;
  
  // ·∫®n h·ªôp k·∫øt qu·∫£
  document.getElementById("result-box").classList.add("hidden");
  
  // Hi·ªán l·∫°i h·ªôp c√¢u h·ªèi
  document.getElementById("questionBox").style.display = "block";
  
  // C·∫≠p nh·∫≠t UI
  updateUI();
  
  // B·∫Øt ƒë·∫ßu timer
  startTimer();
  startEnemyHpIncrease();
  
  // T·∫°o c√¢u h·ªèi m·ªõi
  newQuestion();
  
  // B·∫Øt ƒë·∫ßu game loop
  gameLoop();
}

// Sinh c√¢u h·ªèi "s·ªë ti·∫øp theo"
function newQuestion() {
  if (questionLocked) return;
  
  let n = Math.floor(Math.random() * 15) + 1; // 1-15
  let correct = n + 1;
  currentQuestion = { q: `S·ªë ti·∫øp theo c·ªßa ${n} l√† g√¨?`, answer: correct };

  // t·∫°o 3 ƒë√°p √°n sai
  let answers = [correct];
  while(answers.length < 4){
    let wrong = Math.floor(Math.random() * 20) + 1;
    if(!answers.includes(wrong)) answers.push(wrong);
  }

  // tr·ªôn ng·∫´u nhi√™n
  answers.sort(() => Math.random() - 0.5);

  // render ra UI
  document.getElementById("question").innerText = currentQuestion.q;
  document.getElementById("feedback").innerText = "";
  const answersDiv = document.getElementById("answers");
  answersDiv.innerHTML = "";
  
  answers.forEach(ans => {
    let btn = document.createElement("button");
    btn.innerText = ans;
    btn.className = "answerBtn";
    btn.onclick = () => checkAnswer(ans);
    answersDiv.appendChild(btn);
  });
}

// Ki·ªÉm tra ƒë√°p √°n
function checkAnswer(ans) {
  if (questionLocked) return;
  
  const answersDiv = document.getElementById("answers");
  const buttons = answersDiv.querySelectorAll('.answerBtn');
  
  // V√¥ hi·ªáu h√≥a t·∫•t c·∫£ buttons
  buttons.forEach(btn => btn.disabled = true);
  
  if (ans === currentQuestion.answer) {
    score++;
    correctStreak++;
    document.getElementById("feedback").style.color = "#4CAF50";
    document.getElementById("feedback").innerText = "‚úÖ Ch√≠nh x√°c!";
    
    // K√≠ch ho·∫°t k·ªπ nƒÉng b·∫Øn ƒë√¥i khi ƒë√∫ng 5 c√¢u li√™n ti·∫øp
    if (correctStreak >= 5) {
      doubleShotActive = true;
    }
    
    // K√≠ch ho·∫°t n√∫t k·ªπ nƒÉng khi ƒë·ªß ƒëi·ªÅu ki·ªán
    updateSkillButtons();
    
    // B·∫Øn ƒë·∫°n v√†o qu√°i g·∫ßn nh·∫•t
    if (enemies.length > 0) {
      let nearestEnemy = enemies.reduce((nearest, enemy) => 
        enemy.x < nearest.x ? enemy : nearest
      );
      bullets.push(new Bullet(nearestEnemy));
      
      // B·∫Øn ƒë√¥i n·∫øu k·ªπ nƒÉng ƒëang active
      if (doubleShotActive) {
        let secondNearest = enemies.filter(e => e !== nearestEnemy)
          .reduce((nearest, enemy) => enemy.x < nearest.x ? enemy : nearest, {x: Infinity});
        if (secondNearest.x !== Infinity) {
          bullets.push(new Bullet(secondNearest));
        }
      }
    }
    
    // C√¢u h·ªèi m·ªõi ngay l·∫≠p t·ª©c
    setTimeout(newQuestion, 500);
  } else {
    correctStreak = 0;
    doubleShotActive = false;
    updateSkillButtons();
    
    document.getElementById("feedback").style.color = "#f44336";
    document.getElementById("feedback").innerText = "‚ùå Sai r·ªìi! ƒê·ª£i 1 gi√¢y...";
    
    questionLocked = true;
    // ƒê·ª£i 1 gi√¢y tr∆∞·ªõc khi cho ph√©p tr·∫£ l·ªùi c√¢u h·ªèi m·ªõi
    setTimeout(() => {
      questionLocked = false;
      newQuestion();
    }, 200);
  }
  
  updateUI();
}

// C·∫≠p nh·∫≠t UI
function updateUI() {
  document.getElementById("hpDisplay").innerText = `‚ù§Ô∏è HP Th√†nh: ${castleHP}`;
  document.getElementById("scoreDisplay").innerText = `‚≠ê ƒêi·ªÉm: ${score}`;
}

// C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t k·ªπ nƒÉng
function updateSkillButtons() {
  const rainBtn = document.getElementById("rainSkill");
  const pierceBtn = document.getElementById("pierceSkill");
  
  // C·∫≠p nh·∫≠t n√∫t M∆∞a ƒê·∫°n
  if (correctStreak >= 6) {
    rainBtn.disabled = false;
    rainBtn.innerHTML = "M∆∞a ƒê·∫°n (S·∫µn s√†ng!)";
  } else {
    rainBtn.disabled = true;
    rainBtn.innerHTML = `M∆∞a ƒê·∫°n (${correctStreak}/6)`;
  }
  
  // C·∫≠p nh·∫≠t n√∫t ƒê·∫°n Th·∫ßn
  if (correctStreak >= 10) {
    pierceBtn.disabled = false;
    pierceBtn.innerHTML = "ƒê·∫°n Th·∫ßn (S·∫µn s√†ng!)";
  } else {
    pierceBtn.disabled = true;
    pierceBtn.innerHTML = `ƒê·∫°n Th·∫ßn (${correctStreak}/10)`;
  }
}

// K·ªπ nƒÉng M∆∞a ƒê·∫°n - Hero b·∫Øn ra 6 m≈©i t√™n nh·∫Øm v√†o qu√°i g·∫ßn nh·∫•t
function activateRainSkill() {
  if (correctStreak < 6) return;
  
  // S·∫Øp x·∫øp qu√°i v·∫≠t theo kho·∫£ng c√°ch (g·∫ßn nh·∫•t ƒë·∫ßu ti√™n)
  let sortedEnemies = [...enemies].sort((a, b) => a.x - b.x);
  
  // B·∫Øn 6 m≈©i t√™n v√†o c√°c qu√°i v·∫≠t g·∫ßn nh·∫•t
  for (let i = 0; i < 6; i++) {
    if (sortedEnemies.length > 0) {
      // N·∫øu c√≥ √≠t h∆°n 6 qu√°i, b·∫Øn nhi·ªÅu m≈©i v√†o c√πng m·ªôt qu√°i
      let targetIndex = Math.min(i, sortedEnemies.length - 1);
      bullets.push(new Bullet(sortedEnemies[targetIndex]));
    }
  }
  
  // Reset streak
  correctStreak = 0;
  doubleShotActive = false;
  updateSkillButtons();
}

// K·ªπ nƒÉng ƒê·∫°n Th·∫ßn - Hero b·∫Øn ra 12 m≈©i t√™n nh·∫Øm v√†o qu√°i g·∫ßn nh·∫•t
function activatePierceSkill() {
  if (correctStreak < 10) return;
  
  // S·∫Øp x·∫øp qu√°i v·∫≠t theo kho·∫£ng c√°ch (g·∫ßn nh·∫•t ƒë·∫ßu ti√™n)
  let sortedEnemies = [...enemies].sort((a, b) => a.x - b.x);
  
  // B·∫Øn 12 m≈©i t√™n v√†o c√°c qu√°i v·∫≠t g·∫ßn nh·∫•t
  for (let i = 0; i < 12; i++) {
    if (sortedEnemies.length > 0) {
      // N·∫øu c√≥ √≠t h∆°n 12 qu√°i, b·∫Øn nhi·ªÅu m≈©i v√†o c√πng m·ªôt qu√°i
      let targetIndex = Math.min(i, sortedEnemies.length - 1);
      bullets.push(new Bullet(sortedEnemies[targetIndex]));
    }
  }
  
  // Reset streak
  correctStreak = 0;
  doubleShotActive = false;
  updateSkillButtons();
}

// Spawn qu√°i
const spawnInterval = setInterval(() => {
  if (gameRunning) {
    enemies.push(new Enemy());
  }
}, 7000);

function gameLoop() {
  if (!gameRunning) return;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // V·∫Ω background
  if (images['backgroundthanhtri.png'] && images['backgroundthanhtri.png'].complete) {
    ctx.drawImage(images['backgroundthanhtri.png'], 0, 0, canvas.width, canvas.height);
  } else {
    // Fallback background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(0.7, '#98FB98');
    gradient.addColorStop(1, '#8FBC8F');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // V·∫Ω th√†nh
  if (images['castle.png'] && images['castle.png'].complete) {
    ctx.drawImage(images['castle.png'], 0, 155, 200, 200);
  } else {
    // Fallback castle
    ctx.fillStyle = "#8B4513";
    ctx.fillRect(50, 200, 100, 80);
    ctx.fillStyle = "#654321";
    ctx.fillRect(60, 180, 20, 40);
    ctx.fillRect(100, 180, 20, 40);
    ctx.fillRect(130, 180, 20, 40);
  }

  // V·∫Ω nh√¢n v·∫≠t
  if (images['hero.png'] && images['hero.png'].complete) {
    ctx.drawImage(images['hero.png'], hero.x, hero.y, 40, 50);
  } else {
    // Fallback hero
    ctx.fillStyle = "blue";
    ctx.fillRect(hero.x, hero.y, 30, 40);
  }

  // Enemy update & draw
  for (let e of enemies) e.update();
  enemies = enemies.filter(e => e.hp > 0 && e.x > -50);
  for (let e of enemies) e.draw();

  // Bullet update & draw
  for (let b of bullets) b.update();
  bullets = bullets.filter(b => !b.hit);
  for (let b of bullets) b.draw();

  updateUI();

  if (castleHP <= 0) {
    gameRunning = false;
    clearInterval(spawnInterval);
    
    // Game Over screen
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = "white";
    ctx.font = "bold 40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("üè∞ GAME OVER! üè∞", canvas.width/2, canvas.height/2 - 20);
    
    ctx.font = "20px Arial";
    ctx.fillText(`ƒêi·ªÉm cu·ªëi c√πng: ${score}`, canvas.width/2, canvas.height/2 + 20);
    
    ctx.font = "16px Arial";
    ctx.fillText("ƒêang l∆∞u ƒëi·ªÉm...", canvas.width/2, canvas.height/2 + 50);
    
    // G·ªçi h√†m k·∫øt th√∫c game
    setTimeout(() => endGame(false), 1000);
    return;
  }

  requestAnimationFrame(gameLoop);
}

// Kh·ªüi t·∫°o game
startTimer();
startEnemyHpIncrease();
newQuestion();
gameLoop();

// Th√™m s·ª± ki·ªán cho n√∫t k·ªπ nƒÉng
document.getElementById("rainSkill").addEventListener("click", activateRainSkill);
document.getElementById("pierceSkill").addEventListener("click", activatePierceSkill);
</script>
</body>
</html>