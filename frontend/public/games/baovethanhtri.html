<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Game B·∫£o V·ªá Th√†nh - S·ªë Ti·∫øp Theo</title>
  <style>
    body { margin: 0; background: #222; color: white; text-align: center; font-family: sans-serif; }
    canvas { background: #333; display: block; margin: 10px auto; border: 2px solid #666; }
    #questionBox {
      background: #444;
      padding: 15px;
      margin: 10px auto;
      width: 500px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .answerBtn {
      background: #666;
      color: white;
      border: none;
      padding: 12px 25px;
      margin: 5px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s;
    }
    .answerBtn:hover {
      background: #888;
      transform: translateY(-2px);
    }
    .answerBtn:disabled {
      background: #333;
      cursor: not-allowed;
      opacity: 0.5;
    }
    #gameInfo {
      margin: 10px 0;
      font-size: 18px;
    }
    #skillButtons {
      margin: 15px auto;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .skillBtn {
      background: linear-gradient(45deg, #ff9800, #ff5722);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .skillBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    .skillBtn:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }
    .skillProgress {
      margin-top: 5px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h2>üè∞ Game B·∫£o V·ªá Th√†nh - S·ªë Ti·∫øp Theo üè∞</h2>
  <div id="gameInfo">
    <span id="hpDisplay">‚ù§Ô∏è HP Th√†nh: 100</span> | 
    <span id="scoreDisplay">‚≠ê ƒêi·ªÉm: 0</span>
  </div>
  
  <div id="skillButtons">
    <button id="rainSkill" class="skillBtn" disabled>M∆∞a ƒê·∫°n (6 c√¢u ƒë√∫ng)</button>
    <button id="pierceSkill" class="skillBtn" disabled>ƒê·∫°n Th·∫ßn (10 c√¢u ƒë√∫ng)</button>
  </div>
  
  <canvas id="gameCanvas" width="1000" height="500"></canvas>

  <div id="questionBox">
    <p id="question">C√¢u h·ªèi s·∫Ω hi·ªán ·ªü ƒë√¢y</p>
    <div id="answers"></div>
    <div id="feedback" style="margin-top: 10px; font-weight: bold;"></div>
  </div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let castleHP = 100;
let enemies = [];
let bullets = [];
let currentQuestion = {};
let score = 0;
let gameRunning = true;
let questionLocked = false;

// Bi·∫øn k·ªπ nƒÉng
let correctStreak = 0; // S·ªë c√¢u tr·∫£ l·ªùi ƒë√∫ng li√™n ti·∫øp
let doubleShotActive = false; // K·ªπ nƒÉng b·∫Øn ƒë√¥i

// Load images
const images = {};
const imageFiles = [
  'backgroundthanhtri.png',
  'castle.png',
  'hero.png',
  'arrow.png',
  'monster1.png',
  'monster2.png',
  'monster3.png',
  'monster4.png',
  'monster5.png',
  'monster6.png',
  'monster7.png',
  'monster8.png'
];

let imagesLoaded = 0;
imageFiles.forEach(filename => {
  const img = new Image();
  img.onload = () => {
    imagesLoaded++;
    if (imagesLoaded === imageFiles.length) {
      console.log('T·∫•t c·∫£ h√¨nh ·∫£nh ƒë√£ ƒë∆∞·ª£c t·∫£i!');
    }
  };
  img.onerror = () => {
    console.log(`Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh: ${filename}`);
    imagesLoaded++;
  };
  img.src = filename;
  images[filename] = img;
});

// Nh√¢n v·∫≠t tr√™n th√†nh
const hero = { x: 120, y: 220 };

// Enemy class
class Enemy {
  constructor() {
    this.x = canvas.width;
    this.y = 330;
    this.hp = 80;
    this.maxHP = 80;
    this.speed = 0.4;
    this.width = 80;
    this.height = 100;
    // Ch·ªçn ng·∫´u nhi√™n m·ªôt trong 8 con qu√°i v·∫≠t
    this.monsterType = Math.floor(Math.random() * 8) + 1;
    this.image = images[`monster${this.monsterType}.png`];
  }
  
  update() {
    this.x -= this.speed;
    if (this.x < 160) { // Va ch·∫°m v·ªõi th√†nh
      castleHP -= 15;
      this.hp = 0;
    }
  }
  
  draw() {
    // V·∫Ω qu√°i v·∫≠t
    if (this.image && this.image.complete) {
      ctx.drawImage(this.image, this.x, this.y - this.height, this.width, this.height);
    } else {
      // Fallback n·∫øu kh√¥ng load ƒë∆∞·ª£c h√¨nh
      ctx.fillStyle = `hsl(${this.monsterType * 45}, 70%, 50%)`;
      ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
    }
    
    // Thanh m√°u
    const hpBarWidth = this.width;
    const hpBarHeight = 4;
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(this.x, this.y - this.height - 8, hpBarWidth, hpBarHeight);
    
    ctx.fillStyle = this.hp > this.maxHP * 0.3 ? "green" : "red";
    const hpWidth = (this.hp / this.maxHP) * hpBarWidth;
    ctx.fillRect(this.x, this.y - this.height - 8, hpWidth, hpBarHeight);
  }
}

// Bullet class
class Bullet {
  constructor(target, specialType = null) {
    this.x = hero.x + 30;
    this.y = hero.y + 10;
    this.target = target;
    this.speed = 6;
    this.hit = false;
    this.width = 40;
    this.height = 17;
    this.createdTime = Date.now();
    this.lifetime = 3000; // 3 gi√¢y
    this.specialType = specialType; // 'rain' ho·∫∑c 'pierce'
    
    if (specialType === 'rain') {
      // ƒê·∫°n m∆∞a r∆°i t·ª´ tr√™n xu·ªëng
      this.x = Math.random() * canvas.width;
      this.y = 0;
      this.speed = 4;
    } else if (specialType === 'pierce') {
      // ƒê·∫°n th·∫ßn xuy√™n qua nhi·ªÅu qu√°i
      this.pierceCount = 5; // Xuy√™n qua 5 qu√°i
      this.hitEnemies = []; // Danh s√°ch qu√°i ƒë√£ b·ªã tr√∫ng
    }
  }
  
  update() {
    // Ki·ªÉm tra th·ªùi gian s·ªëng
    if (Date.now() - this.createdTime > this.lifetime) {
      this.hit = true; // ƒê√°nh d·∫•u ƒë·ªÉ x√≥a
      return;
    }
    
    if (this.specialType === 'rain') {
      // ƒê·∫°n m∆∞a r∆°i th·∫≥ng xu·ªëng
      this.y += this.speed;
      
      // Ki·ªÉm tra va ch·∫°m v·ªõi qu√°i
      for (let enemy of enemies) {
        if (enemy.hp > 0 && 
            this.x > enemy.x && this.x < enemy.x + enemy.width &&
            this.y > enemy.y - enemy.height && this.y < enemy.y) {
          enemy.hp -= 25;
          this.hit = true;
          break;
        }
      }
      
      // N·∫øu ra kh·ªèi m√†n h√¨nh
      if (this.y > canvas.height) {
        this.hit = true;
      }
      return;
    }
    
    if (this.specialType === 'pierce') {
      // ƒê·∫°n th·∫ßn bay th·∫≥ng v·ªÅ ph√≠a tr∆∞·ªõc
      this.x += this.speed;
      
      // Ki·ªÉm tra va ch·∫°m v·ªõi qu√°i
      for (let enemy of enemies) {
        if (enemy.hp > 0 && !this.hitEnemies.includes(enemy) &&
            this.x > enemy.x && this.x < enemy.x + enemy.width &&
            this.y > enemy.y - enemy.height && this.y < enemy.y) {
          enemy.hp -= 25;
          this.hitEnemies.push(enemy);
          this.pierceCount--;
          
          if (this.pierceCount <= 0) {
            this.hit = true;
            break;
          }
        }
      }
      
      // N·∫øu ra kh·ªèi m√†n h√¨nh
      if (this.x > canvas.width) {
        this.hit = true;
      }
      return;
    }
    
    // ƒê·∫°n th∆∞·ªùng
    if (!this.target || this.target.hp <= 0) {
      // N·∫øu kh√¥ng c√≥ target, bay th·∫≥ng v·ªÅ ph√≠a tr∆∞·ªõc
      this.x += this.speed;
      if (this.x > canvas.width) {
        this.hit = true;
      }
      return;
    }
    
    let dx = this.target.x - this.x;
    let dy = this.target.y - 20 - this.y;
    let dist = Math.hypot(dx, dy);
    
    if (dist < 25) {
      this.target.hp -= 25;
      this.hit = true;
    } else {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }
  }
  
  draw() {
    if (this.specialType === 'rain') {
      // V·∫Ω ƒë·∫°n m∆∞a
      ctx.fillStyle = "cyan";
      ctx.beginPath();
      ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
      ctx.fill();
    } else if (this.specialType === 'pierce') {
      // V·∫Ω ƒë·∫°n th·∫ßn
      ctx.fillStyle = "gold";
      ctx.beginPath();
      ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
      ctx.fill();
      
      // Hi·ªáu ·ª©ng √°nh s√°ng
      ctx.strokeStyle = "yellow";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
      ctx.stroke();
    } else if (images['arrow.png'] && images['arrow.png'].complete) {
      // ƒê·∫°n th∆∞·ªùng
      ctx.drawImage(images['arrow.png'], this.x - this.width/2, this.y - this.height/2, this.width, this.height);
    } else {
      // Fallback
      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// Sinh c√¢u h·ªèi "s·ªë ti·∫øp theo"
function newQuestion() {
  if (questionLocked) return;
  
  let n = Math.floor(Math.random() * 15) + 1; // 1-15
  let correct = n + 1;
  currentQuestion = { q: `S·ªë ti·∫øp theo c·ªßa ${n} l√† g√¨?`, answer: correct };

  // t·∫°o 3 ƒë√°p √°n sai
  let answers = [correct];
  while(answers.length < 4){
    let wrong = Math.floor(Math.random() * 20) + 1;
    if(!answers.includes(wrong)) answers.push(wrong);
  }

  // tr·ªôn ng·∫´u nhi√™n
  answers.sort(() => Math.random() - 0.5);

  // render ra UI
  document.getElementById("question").innerText = currentQuestion.q;
  document.getElementById("feedback").innerText = "";
  const answersDiv = document.getElementById("answers");
  answersDiv.innerHTML = "";
  
  answers.forEach(ans => {
    let btn = document.createElement("button");
    btn.innerText = ans;
    btn.className = "answerBtn";
    btn.onclick = () => checkAnswer(ans);
    answersDiv.appendChild(btn);
  });
}

// Ki·ªÉm tra ƒë√°p √°n
function checkAnswer(ans) {
  if (questionLocked) return;
  
  const answersDiv = document.getElementById("answers");
  const buttons = answersDiv.querySelectorAll('.answerBtn');
  
  // V√¥ hi·ªáu h√≥a t·∫•t c·∫£ buttons
  buttons.forEach(btn => btn.disabled = true);
  
  if (ans === currentQuestion.answer) {
    score++;
    correctStreak++;
    document.getElementById("feedback").style.color = "#4CAF50";
    document.getElementById("feedback").innerText = "‚úÖ Ch√≠nh x√°c!";
    
    // K√≠ch ho·∫°t k·ªπ nƒÉng b·∫Øn ƒë√¥i khi ƒë√∫ng 5 c√¢u li√™n ti·∫øp
    if (correctStreak >= 5) {
      doubleShotActive = true;
    }
    
    // K√≠ch ho·∫°t n√∫t k·ªπ nƒÉng khi ƒë·ªß ƒëi·ªÅu ki·ªán
    updateSkillButtons();
    
    // B·∫Øn ƒë·∫°n v√†o qu√°i g·∫ßn nh·∫•t
    if (enemies.length > 0) {
      let nearestEnemy = enemies.reduce((nearest, enemy) => 
        enemy.x < nearest.x ? enemy : nearest
      );
      bullets.push(new Bullet(nearestEnemy));
      
      // B·∫Øn ƒë√¥i n·∫øu k·ªπ nƒÉng ƒëang active
      if (doubleShotActive) {
        let secondNearest = enemies.filter(e => e !== nearestEnemy)
          .reduce((nearest, enemy) => enemy.x < nearest.x ? enemy : nearest, {x: Infinity});
        if (secondNearest.x !== Infinity) {
          bullets.push(new Bullet(secondNearest));
        }
      }
    }
    
    // C√¢u h·ªèi m·ªõi ngay l·∫≠p t·ª©c
    setTimeout(newQuestion, 500);
  } else {
    correctStreak = 0;
    doubleShotActive = false;
    updateSkillButtons();
    
    document.getElementById("feedback").style.color = "#f44336";
    document.getElementById("feedback").innerText = "‚ùå Sai r·ªìi! ƒê·ª£i 1 gi√¢y...";
    
    questionLocked = true;
    // ƒê·ª£i 1 gi√¢y tr∆∞·ªõc khi cho ph√©p tr·∫£ l·ªùi c√¢u h·ªèi m·ªõi
    setTimeout(() => {
      questionLocked = false;
      newQuestion();
    }, 200);
  }
  
  updateUI();
}

// C·∫≠p nh·∫≠t UI
function updateUI() {
  document.getElementById("hpDisplay").innerText = `‚ù§Ô∏è HP Th√†nh: ${castleHP}`;
  document.getElementById("scoreDisplay").innerText = `‚≠ê ƒêi·ªÉm: ${score}`;
}

// C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t k·ªπ nƒÉng
function updateSkillButtons() {
  const rainBtn = document.getElementById("rainSkill");
  const pierceBtn = document.getElementById("pierceSkill");
  
  // C·∫≠p nh·∫≠t n√∫t M∆∞a ƒê·∫°n
  if (correctStreak >= 6) {
    rainBtn.disabled = false;
    rainBtn.innerHTML = "M∆∞a ƒê·∫°n (S·∫µn s√†ng!)";
  } else {
    rainBtn.disabled = true;
    rainBtn.innerHTML = `M∆∞a ƒê·∫°n (${correctStreak}/6)`;
  }
  
  // C·∫≠p nh·∫≠t n√∫t ƒê·∫°n Th·∫ßn
  if (correctStreak >= 10) {
    pierceBtn.disabled = false;
    pierceBtn.innerHTML = "ƒê·∫°n Th·∫ßn (S·∫µn s√†ng!)";
  } else {
    pierceBtn.disabled = true;
    pierceBtn.innerHTML = `ƒê·∫°n Th·∫ßn (${correctStreak}/10)`;
  }
}

// K·ªπ nƒÉng M∆∞a ƒê·∫°n
function activateRainSkill() {
  if (correctStreak < 6) return;
  
  // T·∫°o 13 vi√™n ƒë·∫°n m∆∞a
  for (let i = 0; i < 13; i++) {
    bullets.push(new Bullet(null, 'rain'));
  }
  
  // Reset streak
  correctStreak = 0;
  doubleShotActive = false;
  updateSkillButtons();
}

// K·ªπ nƒÉng ƒê·∫°n Th·∫ßn
function activatePierceSkill() {
  if (correctStreak < 6) return;
  
  // T·∫°o ƒë·∫°n th·∫ßn xuy√™n qua 5 qu√°i
  bullets.push(new Bullet(null, 'pierce'));
  
  // Reset streak
  correctStreak = 0;
  doubleShotActive = false;
  updateSkillButtons();
}

// Spawn qu√°i
const spawnInterval = setInterval(() => {
  if (gameRunning) {
    enemies.push(new Enemy());
  }
}, 7000);

function gameLoop() {
  if (!gameRunning) return;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // V·∫Ω background
  if (images['backgroundthanhtri.png'] && images['backgroundthanhtri.png'].complete) {
    ctx.drawImage(images['backgroundthanhtri.png'], 0, 0, canvas.width, canvas.height);
  } else {
    // Fallback background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(0.7, '#98FB98');
    gradient.addColorStop(1, '#8FBC8F');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // V·∫Ω th√†nh
  if (images['castle.png'] && images['castle.png'].complete) {
    ctx.drawImage(images['castle.png'], 0, 155, 200, 200);
  } else {
    // Fallback castle
    ctx.fillStyle = "#8B4513";
    ctx.fillRect(50, 200, 100, 80);
    ctx.fillStyle = "#654321";
    ctx.fillRect(60, 180, 20, 40);
    ctx.fillRect(100, 180, 20, 40);
    ctx.fillRect(130, 180, 20, 40);
  }

  // V·∫Ω nh√¢n v·∫≠t
  if (images['hero.png'] && images['hero.png'].complete) {
    ctx.drawImage(images['hero.png'], hero.x, hero.y, 40, 50);
  } else {
    // Fallback hero
    ctx.fillStyle = "blue";
    ctx.fillRect(hero.x, hero.y, 30, 40);
  }

  // Enemy update & draw
  for (let e of enemies) e.update();
  enemies = enemies.filter(e => e.hp > 0 && e.x > -50);
  for (let e of enemies) e.draw();

  // Bullet update & draw
  for (let b of bullets) b.update();
  bullets = bullets.filter(b => !b.hit);
  for (let b of bullets) b.draw();

  updateUI();

  if (castleHP <= 0) {
    gameRunning = false;
    clearInterval(spawnInterval);
    
    // Game Over screen
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = "white";
    ctx.font = "bold 40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("üè∞ GAME OVER! üè∞", canvas.width/2, canvas.height/2 - 20);
    
    ctx.font = "20px Arial";
    ctx.fillText(`ƒêi·ªÉm cu·ªëi c√πng: ${score}`, canvas.width/2, canvas.height/2 + 20);
    
    ctx.font = "16px Arial";
    ctx.fillText("Nh·∫•n F5 ƒë·ªÉ ch∆°i l·∫°i", canvas.width/2, canvas.height/2 + 50);
    return;
  }

  requestAnimationFrame(gameLoop);
}

// Kh·ªüi t·∫°o game
newQuestion();
gameLoop();

// Th√™m s·ª± ki·ªán cho n√∫t k·ªπ nƒÉng
document.getElementById("rainSkill").addEventListener("click", activateRainSkill);
document.getElementById("pierceSkill").addEventListener("click", activatePierceSkill);
</script>
</body>
</html>