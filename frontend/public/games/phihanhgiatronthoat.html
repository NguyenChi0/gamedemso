<!DOCTYPE html>
<html>
<head>
  <title>Game ƒê·∫øm S·ªë ƒê∆°n Gi·∫£n</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      font-family: 'Arial', sans-serif;
      overflow: hidden;
    }
    #game-container {
      position: relative;
      width: 800px;
      height: 600px;
      border: 3px solid #4a90e2;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    }
    canvas { 
      display: block; 
      border-radius: 8px;
    }
    #ui {
      position: absolute;
      top: 15px;
      left: 15px;
      color: white;
      font-family: 'Arial', sans-serif;
      font-size: 18px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      z-index: 10;
    }
    .ui-item {
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid #4a90e2;
    }
    #instructions {
      position: absolute;
      bottom: 15px;
      left: 15px;
      color: #ccc;
      font-size: 14px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    .instruction-line {
      margin-bottom: 3px;
    }
    #level-transition {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      font-size: 36px;
      z-index: 100;
      display: none;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="ui">
      <div class="ui-item">üèÜ ƒêi·ªÉm: <span id="score">0</span></div>
      <div class="ui-item">ü™ô Xu: <span id="coinsCollected">0/10</span></div>
      <div class="ui-item">üéØ Ti·∫øp theo: <span id="nextCoin">1</span></div>
      <div class="ui-item">üöÄ C·∫•p ƒë·ªô: <span id="level">1</span></div>
    </div>
    <div id="instructions">
      <div class="instruction-line">‚¨ÖÔ∏è ‚û°Ô∏è Di chuy·ªÉn</div>
      <div class="instruction-line">üöÄ SPACE Bay</div>
      <div class="instruction-line">üîÑ R Ch∆°i l·∫°i</div>
    </div>
    <div id="level-transition">
      <h2>Ch√∫c m·ª´ng!</h2>
      <p>B·∫°n ƒë√£ ho√†n th√†nh c·∫•p ƒë·ªô <span id="current-level">1</span></p>
      <p>Chu·∫©n b·ªã cho c·∫•p ƒë·ªô ti·∫øp theo...</p>
    </div>
  </div>

  <script>
    let player;
    let coins = [];
    let platforms = [];
    let particles = [];
    let portal;
    let score = 0;
    let nextCoinToCollect = 1;
    let gravity = 0.1;
    let flyForce = -0.2;
    let isFlying = false;
    let moveState = { left: false, right: false };
    let gameLost = false;
    let gameWon = false;
    let stars = [];
    let gameTime = 0;
    let currentLevel = 1;
    let coinsPerLevel = 10;
    let isLevelTransition = false;
    let transitionTimer = 0;
    let astronautImg;

    function preload() {
  astronautImg = loadImage("phihanhgia3.png");
}



    function setup() {
      let canvas = createCanvas(800, 600);
      canvas.parent('game-container');
      
      resetGame();
      
      // T·∫°o c√°c ng√¥i sao n·ªÅn
      for (let i = 0; i < 100; i++) {
        stars.push({
          x: random(width),
          y: random(height),
          size: random(1, 3),
          brightness: random(100, 255)
        });
      }
    }

    function initializeLevel() {
      player = { 
        x: 50, 
        y: 500, 
        size: 40, 
        vx: 0, 
        vy: 0 
      };
      
      // T·∫°o c√°c b·∫≠c thang v·ªõi m√†u s·∫Øc gradient
      platforms = [
        { x: 0, y: 550, w: 800, h: 50, color: [100, 50, 25] },
        { x: 100, y: 450, w: 200, h: 20, color: [120, 60, 30] },
        { x: 450, y: 350, w: 200, h: 20, color: [140, 70, 35] },
        { x: 150, y: 250, w: 200, h: 20, color: [160, 80, 40] },
        { x: 500, y: 150, w: 200, h: 20, color: [180, 90, 45] },
        { x: 300, y: 50, w: 150, h: 20, color: [200, 100, 50] }
      ];
      
      // T√≠nh to√°n gi√° tr·ªã xu cho c·∫•p ƒë·ªô hi·ªán t·∫°i
      let startValue = (currentLevel - 1) * coinsPerLevel + 1;
      let endValue = currentLevel * coinsPerLevel;
      
      // V·ªã tr√≠ c√°c ƒë·ªìng xu
      let coinPositions = [
        { x: 350, y: 20 }, { x: 150, y: 420 }, { x: 250, y: 420 },
        { x: 500, y: 320 }, { x: 600, y: 320 }, { x: 200, y: 220 },
        { x: 300, y: 220 }, { x: 550, y: 120 }, { x: 650, y: 120 },
        { x: 450, y: 20 }
      ];
      
      // G√°n gi√° tr·ªã ng·∫´u nhi√™n cho c√°c ƒë·ªìng xu
      let values = Array.from({length: coinsPerLevel}, (_, i) => startValue + i);
      for (let i = values.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [values[i], values[j]] = [values[j], values[i]];
      }
      
      coins = coinPositions.map((pos, index) => ({
        ...pos,
        value: values[index],
        collected: false,
        pulse: 0
      }));
      
      // T·∫°o c√°nh c·ªïng
      portal = {
        x: 375,
        y: 20,
        size: 50,
        active: false,
        pulse: 0
      };
      
      // Reset tr·∫°ng th√°i game
      nextCoinToCollect = startValue;
      gameLost = false;
      gameWon = false;
      isLevelTransition = false;
      transitionTimer = 0;
    }

    function draw() {
      if (isLevelTransition) {
        drawLevelTransition();
        return;
      }
      
      gameTime++;
      
      // V·∫Ω background gradient - ƒê√É S·ª¨A L·ªñI ·ªû ƒê√ÇY
      drawBackground();
      
      // V·∫Ω c√°c ng√¥i sao
      drawStars();
      
      // V·∫Ω b·∫≠c thang v·ªõi hi·ªáu ·ª©ng
      drawPlatforms();
      
      // V·∫Ω c√°nh c·ªïng
      drawPortal();
      
      // C·∫≠p nh·∫≠t v√† v·∫Ω particles (l·ª≠a)
      updateParticles();
      
      // C·∫≠p nh·∫≠t v√† v·∫Ω nh√¢n v·∫≠t
      if (!gameLost && !gameWon) updatePlayer();
      drawPlayer();
      
      // V·∫Ω ƒë·ªìng xu v·ªõi hi·ªáu ·ª©ng
      drawCoins();
      
      // C·∫≠p nh·∫≠t UI
      updateUI();
      
      // Ki·ªÉm tra th·∫Øng game
      if (gameWon) {
        drawWinScreen();
      }
      
      // Ki·ªÉm tra thua game
      if (gameLost) {
        drawGameOverScreen();
      }
    }

    function drawBackground() {
      // S·ª≠ d·ª•ng gradient t·ª´ CSS thay v√¨ v·∫Ω t·ª´ng d√≤ng
      clear();
      push();
      // V·∫Ω n·ªÅn gradient gi·ªëng v·ªõi CSS
      drawingContext.fillStyle = 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)';
      rect(0, 0, width, height);
      pop();
    }

    function drawLevelTransition() {
      background(0, 0, 0, 200);
      
      fill(255, 255, 0);
      textSize(36);
      textAlign(CENTER, CENTER);
      textStyle(BOLD);
      text(`üéâ C·∫§P ƒê·ªò ${currentLevel - 1} HO√ÄN TH√ÄNH! üéâ`, width/2, height/2 - 40);
      
      fill(255);
      textSize(24);
      text(`Chu·∫©n b·ªã cho c·∫•p ƒë·ªô ${currentLevel}...`, width/2, height/2);
      
      textSize(18);
      text(`ƒêi·ªÉm s·ªë: ${score}`, width/2, height/2 + 40);
      
      // ƒê·∫øm ng∆∞·ª£c ƒë·ªÉ chuy·ªÉn c·∫•p ƒë·ªô
      transitionTimer++;
      if (transitionTimer > 180) { // 3 gi√¢y v·ªõi 60fps
        isLevelTransition = false;
        initializeLevel();
      }
    }

    function drawStars() {
      noStroke();
      for (let star of stars) {
        fill(255, 255, 255, star.brightness + sin(gameTime * 0.02 + star.x) * 50);
        ellipse(star.x, star.y, star.size, star.size);
      }
    }

    function drawPlatforms() {
      noStroke();
      for (let p of platforms) {
        fill(0, 0, 0, 100);
        rect(p.x + 3, p.y + 3, p.w, p.h);
        
        for (let i = 0; i < p.h; i++) {
          let inter = map(i, 0, p.h, 0, 1);
          let c = lerpColor(
            color(p.color[0], p.color[1], p.color[2]),
            color(p.color[0] * 0.6, p.color[1] * 0.6, p.color[2] * 0.6),
            inter
          );
          stroke(c);
          line(p.x, p.y + i, p.x + p.w, p.y + i);
        }
      }
    }

    function drawPortal() {
      if (portal.active) {
        portal.pulse += 0.05;
        let pulseSize = portal.size + sin(portal.pulse * 2) * 10;
        
        // V·∫Ω v√≤ng s√°ng xung quanh
        noStroke();
        fill(0, 255, 255, 100);
        ellipse(portal.x, portal.y, pulseSize + 20, pulseSize + 20);
        
        // V·∫Ω c·ªïng ch√≠nh
        fill(0, 200, 255);
        ellipse(portal.x, portal.y, portal.size, portal.size);
        
        // Hi·ªáu ·ª©ng xo√°y
        stroke(255, 255, 255, 150);
        strokeWeight(2);
        noFill();
        for (let i = 0; i < 3; i++) {
          let angle = portal.pulse + i * TWO_PI / 3;
          let r = portal.size * 0.3;
          arc(portal.x, portal.y, r, r, angle, angle + PI);
        }
      } else {
        // C·ªïng ch∆∞a m·ªü
        noStroke();
        fill(100, 100, 100, 150);
        ellipse(portal.x, portal.y, portal.size, portal.size);
      }
    }

    function updatePlayer() {
      if (isFlying) {
        createFireParticles();
      }
      
      if (!isFlying) {
        player.vy += gravity;
      } else {
        player.vy += flyForce;
      }
      
      if (moveState.left) player.vx = -5;
      else if (moveState.right) player.vx = 5;
      else player.vx *= 0.8;
      
      let oldX = player.x;
      let oldY = player.y;
      
      player.x += player.vx;
      player.y += player.vy;
      
      for (let p of platforms) {
        if (player.x + player.size/2 > p.x && 
            player.x - player.size/2 < p.x + p.w &&
            player.y + player.size/2 > p.y && 
            player.y - player.size/2 < p.y + p.h) {
          
          if (oldY + player.size/2 <= p.y && player.vy > 0) {
            player.y = p.y - player.size/2;
            player.vy = 0;
          }
          else if (oldY - player.size/2 >= p.y + p.h && player.vy < 0) {
            player.y = p.y + p.h + player.size/2;
            player.vy = 0;
          }
          else if (oldX + player.size/2 <= p.x && player.vx > 0) {
            player.x = p.x - player.size/2;
            player.vx = 0;
          }
          else if (oldX - player.size/2 >= p.x + p.w && player.vx < 0) {
            player.x = p.x + p.w + player.size/2;
            player.vx = 0;
          }
        }
      }
      
      if (player.x - player.size/2 < 0) {
        player.x = player.size/2;
        player.vx = 0;
      }
      if (player.x + player.size/2 > width) {
        player.x = width - player.size/2;
        player.vx = 0;
      }
      if (player.y - player.size/2 < 0) {
        player.y = player.size/2;
        player.vy = 0;
      }
      if (player.y + player.size/2 > height) {
        player.y = height - player.size/2;
        player.vy = 0;
      }
      
      // Thu th·∫≠p xu
      for (let c of coins) {
        if (!c.collected && dist(player.x, player.y, c.x, c.y) < player.size/2 + 15) {
          if (c.value === nextCoinToCollect) {
            c.collected = true;
            score += c.value;
            nextCoinToCollect++;
            createCollectEffect(c.x, c.y);
            // K√≠ch ho·∫°t c·ªïng khi thu th·∫≠p ƒë·ªß xu
            if (nextCoinToCollect > currentLevel * coinsPerLevel) {
              portal.active = true;
            }
          } else if (c.value > nextCoinToCollect) {
            gameLost = true;
          }
        }
      }
      
      // Ki·ªÉm tra va ch·∫°m v·ªõi c·ªïng
      if (portal.active && dist(player.x, player.y, portal.x, portal.y) < (player.size + portal.size)/2) {
        if (currentLevel < 5) { // Gi·ªõi h·∫°n 5 c·∫•p ƒë·ªô, b·∫°n c√≥ th·ªÉ thay ƒë·ªïi
          currentLevel++;
          isLevelTransition = true;
          transitionTimer = 0;
        } else {
          gameWon = true;
        }
      }
    }

    function drawPlayer() {
  push();
  imageMode(CENTER);
  image(astronautImg, player.x, player.y, player.size, player.size);
  pop();
}


    function createFireParticles() {
      for (let i = 0; i < random(3, 6); i++) {
        particles.push({
          x: player.x + random(-player.size/4, player.size/4),
          y: player.y + player.size/2,
          vx: random(-2, 2),
          vy: random(2, 5),
          life: 255,
          maxLife: 255,
          color: random(['orange', 'red', 'yellow'])
        });
      }
    }

    function createCollectEffect(x, y) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x,
          y: y,
          vx: random(-5, 5),
          vy: random(-5, 5),
          life: 255,
          maxLife: 255,
          color: 'gold'
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 5;
        
        let alpha = map(p.life, 0, p.maxLife, 0, 255);
        noStroke();
        
        if (p.color === 'orange') {
          fill(255, 165, 0, alpha);
        } else if (p.color === 'red') {
          fill(255, 0, 0, alpha);
        } else if (p.color === 'yellow') {
          fill(255, 255, 0, alpha);
        } else if (p.color === 'gold') {
          fill(255, 215, 0, alpha);
        }
        
        ellipse(p.x, p.y, 8, 8);
        
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function drawCoins() {
      textAlign(CENTER, CENTER);
      for (let c of coins) {
        if (!c.collected) {
          c.pulse += 0.1;
          
          if (c.value === nextCoinToCollect) {
            let pulseSize = 30 + sin(c.pulse * 2) * 5;
            fill(255, 255, 0, 150);
            ellipse(c.x, c.y, pulseSize + 10, pulseSize + 10);
          }
          
          fill(255, 215, 0);
          stroke(255, 180, 0);
          strokeWeight(2);
          ellipse(c.x, c.y, 25, 25);
          
          fill(0);
          noStroke();
          textSize(12);
          textStyle(BOLD);
          text(c.value, c.x, c.y);
        }
      }
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('coinsCollected').textContent = `${nextCoinToCollect - (currentLevel - 1) * coinsPerLevel - 1}/${coinsPerLevel}`;
      document.getElementById('nextCoin').textContent = nextCoinToCollect <= currentLevel * coinsPerLevel ? nextCoinToCollect : 'T√¨m c·ªïng!';
      document.getElementById('level').textContent = currentLevel;
      document.getElementById('current-level').textContent = currentLevel - 1;
    }

    function drawWinScreen() {
      fill(0, 0, 0, 200);
      rect(0, 0, width, height);
      
      if (frameCount % 10 === 0) {
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: random(width),
            y: random(height/2),
            vx: random(-3, 3),
            vy: random(-3, 3),
            life: 255,
            maxLife: 255,
            color: random(['orange', 'red', 'yellow', 'gold'])
          });
        }
      }
      
      fill(255, 255, 0);
      textSize(36);
      textAlign(CENTER, CENTER);
      textStyle(BOLD);
      text("üéâ CH√öC M·ª™NG! üéâ", width/2, height/2 - 40);
      
      fill(255);
      textSize(24);
      text("B·∫†N ƒê√É HO√ÄN TH√ÄNH T·∫§T C·∫¢ C·∫§P ƒê·ªò!", width/2, height/2);
      
      textSize(18);
      text(`ƒêi·ªÉm s·ªë cu·ªëi c√πng: ${score}`, width/2, height/2 + 40);
      
      noLoop();
    }

    function drawGameOverScreen() {
      fill(0, 0, 0, 200);
      rect(0, 0, width, height);
      
      fill(255, 100, 100);
      textSize(36);
      textAlign(CENTER, CENTER);
      textStyle(BOLD);
      text("üí• GAME OVER üí•", width/2, height/2 - 40);
      
      fill(255);
      textSize(20);
      text("B·∫°n ƒë√£ thu th·∫≠p sai th·ª© t·ª±!", width/2, height/2);
      text("Nh·∫•n R ƒë·ªÉ ch∆°i l·∫°i", width/2, height/2 + 40);
    }

    function keyPressed() {
      if ((gameLost || gameWon) && key === 'r') {
        resetGame();
        loop();
        return;
      }
      
      if (keyCode === LEFT_ARROW) moveState.left = true;
      if (keyCode === RIGHT_ARROW) moveState.right = true;
      if (key === ' ') isFlying = true;
    }

    function keyReleased() {
      if (keyCode === LEFT_ARROW) moveState.left = false;
      if (keyCode === RIGHT_ARROW) moveState.right = false;
      if (key === ' ') isFlying = false;
    }

    function resetGame() {
      currentLevel = 1;
      score = 0;
      particles = [];
      gameTime = 0;
      initializeLevel();
    }

    window.addEventListener('keydown', function(e) {
      if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].indexOf(e.code) > -1) {
        e.preventDefault();
      }
    }, false);
  </script>
</body>
</html>