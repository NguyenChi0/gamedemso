<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Game G·∫Øp B√≥ng V·∫≠t L√Ω - ƒê·∫øn 50</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Arial', sans-serif;
      color: #fff;
    }
    
    .game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    
    canvas {
      background: linear-gradient(to bottom, #2c3e50, #34495e);
      border: 5px solid #ecf0f1;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    
    .controls {
      display: flex;
      gap: 20px;
      align-items: center;
      background: rgba(255,255,255,0.1);
      padding: 15px 25px;
      border-radius: 25px;
      backdrop-filter: blur(10px);
    }
    
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(45deg, #3498db, #2980b9);
      color: white;
      box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
    }
    
    .btn.shuffle {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
    }
    
    .btn.shuffle:hover {
      box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
    }
    
    .info {
      text-align: center;
      background: rgba(255,255,255,0.1);
      padding: 10px 20px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      max-width: 600px;
    }
    
    .guide {
      font-size: 16px;
      margin-bottom: 5px;
      opacity: 0.9;
    }
    
    .message {
      font-size: 20px;
      font-weight: bold;
      color: #f39c12;
      min-height: 25px;
    }
    
    .score {
      font-size: 18px;
      color: #2ecc71;
      margin-top: 5px;
    }
    
    .level-selector {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .level-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 15px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: rgba(255,255,255,0.2);
      color: white;
    }
    
    .level-btn.active {
      background: linear-gradient(45deg, #9b59b6, #8e44ad);
      box-shadow: 0 4px 10px rgba(155, 89, 182, 0.4);
    }
    
    .level-btn:hover {
      background: rgba(255,255,255,0.3);
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="info">
      <div class="guide">‚Üê ‚Üí ƒë·ªÉ di chuy·ªÉn | Space ho·∫∑c ‚Üì ƒë·ªÉ g·∫Øp</div>
      <div class="message" id="message"></div>
      <div class="score">ƒê√£ g·∫Øp theo th·ª© t·ª±: <span id="scoreText">Ch∆∞a c√≥</span></div>
      <div class="level-selector">
        <button class="level-btn active" onclick="changeLevel(10)">M·ª©c d·ªÖ (1-10)</button>
        <button class="level-btn" onclick="changeLevel(20)">M·ª©c trung (1-20)</button>
        <button class="level-btn" onclick="changeLevel(50)">M·ª©c kh√≥ (1-50)</button>
      </div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
      <button class="btn shuffle" onclick="shuffleBalls()">üå™Ô∏è X√°o Tr·ªôn</button>
      <button class="btn" onclick="resetGame()">üîÑ Ch∆°i L·∫°i</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const messageBox = document.getElementById("message");
    const scoreText = document.getElementById("scoreText");
    const levelButtons = document.querySelectorAll('.level-btn');

    // Th√¥ng s·ªë v·∫≠t l√Ω
    const GRAVITY = 0.5;
    const BOUNCE = 0.3;
    const FRICTION = 0.1;
    const AIR_RESISTANCE = 0.998;
    
    // Th√¥ng s·ªë game
    let clawX = canvas.width / 2;
    let clawWidth = 50;
    let clawHeight = 25;
    let clawMove = 13;
    let ropeLength = 60;
    let isDropping = false;
    let isReturning = false;
    let nextTarget = 1;
    let caughtNumbers = [];
    let maxBalls = 10; // M·∫∑c ƒë·ªãnh l√† 10 b√≥ng
    
    // T·∫°o b√≥ng
    let balls = [];
    
    function initBalls() {
      balls = [];
      const ballSize = maxBalls <= 10 ? 45 : maxBalls <= 20 ? 35 : 25;
      
      for (let i = 1; i <= maxBalls; i++) {
        balls.push({
          x: Math.random() * (canvas.width - 100) + 50,
          y: Math.random() * 150 + (canvas.height - 200),
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 2,
          size: ballSize,
          num: i,
          caught: false,
          onGround: false,
          mass: 4 + Math.random() * 0.5
        });
      }
    }
    
    let caughtBall = null;
    
    function drawClaw() {
      // V·∫Ω thanh treo
      ctx.strokeStyle = "#95a5a6";
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(0, 30);
      ctx.lineTo(canvas.width, 30);
      ctx.stroke();
      
      // V·∫Ω d√¢y c√°p
      ctx.strokeStyle = "#7f8c8d";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(clawX, 30);
      ctx.lineTo(clawX, ropeLength + 30);
      ctx.stroke();
      
      // V·∫Ω ƒë·∫ßu g·∫Øp
      const clawY = ropeLength + 30;
      
      // Th√¢n g·∫Øp
      ctx.fillStyle = "#ecf0f1";
      ctx.fillRect(clawX - clawWidth / 2, clawY, clawWidth, clawHeight);
      
      // Chi ti·∫øt g·∫Øp
      ctx.fillStyle = "#bdc3c7";
      ctx.fillRect(clawX - clawWidth / 2, clawY, 5, clawHeight + 10);
      ctx.fillRect(clawX + clawWidth / 2 - 5, clawY, 5, clawHeight + 10);
      
      // M√≥c g·∫Øp
      ctx.strokeStyle = "#95a5a6";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(clawX - clawWidth / 3, clawY + clawHeight + 8, 8, 0, Math.PI);
      ctx.arc(clawX + clawWidth / 3, clawY + clawHeight + 8, 8, 0, Math.PI);
      ctx.stroke();
    }
    
    function getColorForNumber(num) {
      // T·∫°o m√†u d·ª±a tr√™n s·ªë
      const hue = (num * 137.508) % 360; // S·ª≠ d·ª•ng g√≥c v√†ng ƒë·ªÉ ph√¢n b·ªë ƒë·ªÅu m√†u s·∫Øc
      return `hsl(${hue}, 70%, 60%)`;
    }
    
    function drawBalls() {
      balls.forEach(ball => {
        if (!ball.caught) {
          // B√≥ng v·ªõi gradient
          const mainColor = getColorForNumber(ball.num);
          const darkColor = mainColor.replace('60%)', '50%)');
          
          const gradient = ctx.createRadialGradient(
            ball.x - ball.size/6, ball.y - ball.size/6, 0,
            ball.x, ball.y, ball.size / 2
          );
          
          gradient.addColorStop(0, darkColor);
          gradient.addColorStop(1, mainColor);
          
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, ball.size / 2, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();
          
          // Vi·ªÅn
          ctx.strokeStyle = "rgba(255,255,255,0.3)";
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // S·ªë
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const fontSize = ball.size / 2.5;
          ctx.font = `bold ${fontSize}px Arial`;
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 3;
          ctx.strokeText(ball.num, ball.x, ball.y);
          ctx.fillText(ball.num, ball.x, ball.y);
          
          // Highlight cho s·ªë c·∫ßn g·∫Øp ti·∫øp theo
          if (ball.num === nextTarget) {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.size / 2 + 8, 0, Math.PI * 2);
            ctx.strokeStyle = "#f1c40f";
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }
      });
    }
    
    function updateBalls() {
      const ground = canvas.height - 20;
      
      balls.forEach(ball => {
        if (!ball.caught) {
          // √Åp d·ª•ng tr·ªçng l·ª±c
          ball.vy += GRAVITY;
          
          // √Åp d·ª•ng l·ª±c c·∫£n kh√¥ng kh√≠
          ball.vx *= AIR_RESISTANCE;
          ball.vy *= AIR_RESISTANCE;
          
          // C·∫≠p nh·∫≠t v·ªã tr√≠
          ball.x += ball.vx;
          ball.y += ball.vy;
          
          // Va ch·∫°m v·ªõi ƒë·∫•t
          if (ball.y + ball.size / 2 > ground) {
            ball.y = ground - ball.size / 2;
            ball.vy *= -BOUNCE;
            ball.vx *= FRICTION;
            ball.onGround = true;
            
            // D·ª´ng l·∫°i n·∫øu v·∫≠n t·ªëc qu√° nh·ªè
            if (Math.abs(ball.vy) < 0.5) ball.vy = 0;
            if (Math.abs(ball.vx) < 0.2) ball.vx = 0;
          } else {
            ball.onGround = false;
          }
          
          // Va ch·∫°m v·ªõi t∆∞·ªùng
          if (ball.x - ball.size / 2 < 0) {
            ball.x = ball.size / 2;
            ball.vx *= -BOUNCE;
          }
          if (ball.x + ball.size / 2 > canvas.width) {
            ball.x = canvas.width - ball.size / 2;
            ball.vx *= -BOUNCE;
          }
          
          // Va ch·∫°m v·ªõi tr·∫ßn (v√πng g·∫Øp)
          if (ball.y - ball.size / 2 < 60) {
            ball.y = 60 + ball.size / 2;
            ball.vy *= -BOUNCE;
          }
          
          // Va ch·∫°m gi·ªØa c√°c b√≥ng
          balls.forEach(other => {
            if (ball !== other && !other.caught && !ball.caught) {
              let dx = ball.x - other.x;
              let dy = ball.y - other.y;
              let dist = Math.sqrt(dx * dx + dy * dy);
              let minDist = (ball.size + other.size) / 2;
              
              if (dist < minDist && dist > 0) {
                // T√°ch b√≥ng ra kh·ªèi nhau
                let overlap = minDist - dist;
                let separationX = (dx / dist) * overlap * 0.5;
                let separationY = (dy / dist) * overlap * 0.5;
                
                ball.x += separationX;
                ball.y += separationY;
                other.x -= separationX;
                other.y -= separationY;
                
                // T√≠nh to√°n va ch·∫°m ƒë√†n h·ªìi
                let relativeVelX = ball.vx - other.vx;
                let relativeVelY = ball.vy - other.vy;
                
                let speed = relativeVelX * dx / dist + relativeVelY * dy / dist;
                
                if (speed < 0) return;
                
                speed *= BOUNCE;
                
                let impulseX = speed * dx / dist;
                let impulseY = speed * dy / dist;
                
                let totalMass = ball.mass + other.mass;
                
                ball.vx -= impulseX * other.mass / totalMass;
                ball.vy -= impulseY * other.mass / totalMass;
                other.vx += impulseX * ball.mass / totalMass;
                other.vy += impulseY * ball.mass / totalMass;
              }
            }
          });
        }
      });
    }
    
    function updateClaw() {
      if (isDropping) {
        ropeLength += 8;
        let clawTipX = clawX;
        let clawTipY = ropeLength + 30 + clawHeight;
        
        if (ropeLength > canvas.height - 100) {
          isDropping = false;
          isReturning = true;
        }
        
        // Ki·ªÉm tra g·∫Øp b√≥ng
        balls.forEach(ball => {
          if (!ball.caught) {
            let dx = clawTipX - ball.x;
            let dy = clawTipY - ball.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < ball.size / 2 + clawWidth / 3) {
              ball.caught = true;
              caughtBall = ball;
              isDropping = false;
              isReturning = true;
            }
          }
        });
        
      } else if (isReturning) {
        ropeLength -= 8;
        
        if (caughtBall) {
          caughtBall.x = clawX;
          caughtBall.y = ropeLength + 30 + clawHeight + caughtBall.size / 2;
          caughtBall.vx = 0;
          caughtBall.vy = 0;
        }
        
        if (ropeLength <= 60) {
          isReturning = false;
          
          if (caughtBall) {
            if (caughtBall.num === nextTarget) {
              // G·∫Øp ƒë√∫ng s·ªë
              caughtNumbers.push(caughtBall.num);
              nextTarget++;
              
              messageBox.innerText = `Tuy·ªát v·ªùi! ƒê√£ g·∫Øp s·ªë ${caughtBall.num} üéâ`;
              
              if (nextTarget > maxBalls) {
                messageBox.innerText = `Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh ${maxBalls} s·ªë! üèÜ`;
                setTimeout(() => {
                  if (confirm(`Ch√∫c m·ª´ng b·∫°n ƒë√£ th·∫Øng v·ªõi ${maxBalls} s·ªë! Ch∆°i l·∫°i kh√¥ng?`)) {
                    resetGame();
                  }
                }, 1000);
              }
              
            } else {
              // G·∫Øp sai s·ªë
              messageBox.innerText = `Sai r·ªìi! C·∫ßn g·∫Øp s·ªë ${nextTarget}, kh√¥ng ph·∫£i ${caughtBall.num} ‚ùå`;
            }
            
            // X√≥a b√≥ng ƒë√£ g·∫Øp
            balls = balls.filter(b => b !== caughtBall);
            caughtBall = null;
            
            updateScore();
            setTimeout(() => messageBox.innerText = "", 3000);
          }
        }
      }
    }
    
    function updateScore() {
      if (caughtNumbers.length === 0) {
        scoreText.innerText = "Ch∆∞a c√≥";
      } else {
        scoreText.innerText = caughtNumbers.join(", ") + ` (Ti·∫øp theo: ${nextTarget > maxBalls ? "Ho√†n th√†nh!" : nextTarget})`;
      }
    }
    
    function shuffleBalls() {
      balls.forEach(ball => {
        if (!ball.caught) {
          // Th·ªïi b√≥ng l√™n cao v·ªõi l·ª±c ng·∫´u nhi√™n
          ball.vy = -(Math.random() * 15 + 10);
          ball.vx = (Math.random() - 0.5) * 10;
          ball.y = Math.min(ball.y, canvas.height - 100);
        }
      });
      
      messageBox.innerText = "ƒê√£ x√°o tr·ªôn c√°c b√≥ng! üå™Ô∏è";
      setTimeout(() => messageBox.innerText = "", 2000);
    }
    
    function resetGame() {
      nextTarget = 1;
      caughtNumbers = [];
      caughtBall = null;
      isDropping = false;
      isReturning = false;
      ropeLength = 60;
      clawX = canvas.width / 2;
      
      initBalls();
      updateScore();
      messageBox.innerText = `Game m·ªõi b·∫Øt ƒë·∫ßu! H√£y g·∫Øp t·ª´ s·ªë 1 ƒë·∫øn ${maxBalls} theo th·ª© t·ª±! üéÆ`;
      setTimeout(() => messageBox.innerText = "", 3000);
    }
    
    function changeLevel(level) {
      maxBalls = level;
      
      // C·∫≠p nh·∫≠t n√∫t active
      levelButtons.forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc canvas cho nhi·ªÅu b√≥ng h∆°n
      if (maxBalls > 20) {
        canvas.width = 900;
        canvas.height = 700;
      } else if (maxBalls > 10) {
        canvas.width = 800;
        canvas.height = 600;
      } else {
        canvas.width = 600;
        canvas.height = 500;
      }
      
      resetGame();
    }
    
    function gameLoop() {
      // V·∫Ω n·ªÅn gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#34495e");
      gradient.addColorStop(1, "#2c3e50");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // V·∫Ω ƒë∆∞·ªùng ƒë·∫•t
      ctx.fillStyle = "#8b4513";
      ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
      
      drawClaw();
      drawBalls();
      updateBalls();
      updateClaw();
      requestAnimationFrame(gameLoop);
    }
    
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft" && !isDropping && !isReturning && clawX > clawWidth / 2) {
        clawX -= clawMove;
      } else if (e.key === "ArrowRight" && !isDropping && !isReturning && clawX < canvas.width - clawWidth / 2) {
        clawX += clawMove;
      } else if ((e.key === " " || e.key === "ArrowDown") && !isDropping && !isReturning) {
        e.preventDefault();
        isDropping = true;
      }
    });
    
    // Kh·ªüi t·∫°o game
    initBalls();
    updateScore();
    messageBox.innerText = "Ch√†o m·ª´ng! H√£y g·∫Øp c√°c s·ªë t·ª´ 1 ƒë·∫øn 10 theo ƒë√∫ng th·ª© t·ª±! üéÆ";
    setTimeout(() => messageBox.innerText = "", 3000);
    
    gameLoop();
  </script>
</body>
</html>